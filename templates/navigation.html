<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flood-Safe Navigation</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css">
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    #floodMap {
      height: 500px;
      width: 100%;
      border-radius: 0.5rem;
      border: 1px solid #e5e7eb;
    }
    .risk-indicator {
      transition: all 0.3s ease;
    }
    .pulse-ring {
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(0.8); opacity: 0.7; }
      70% { transform: scale(1.3); opacity: 0.1; }
      100% { transform: scale(0.8); opacity: 0; }
    }
    #startSuggestions, #endSuggestions {
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
    }
    #startSuggestions div, #endSuggestions div {
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
    }
    #startSuggestions div:hover, #endSuggestions div:hover {
      background-color: #f3f4f6;
    }
    .user-location-marker {
      background: transparent;
      border: none;
    }
    .user-location-marker i {
      filter: drop-shadow(0 0 2px rgba(0,0,0,0.3));
      color: #3b82f6;
    }
    .transport-mode.active {
      background-color: #3b82f6;
      color: white;
    }
    #walkMode {
      display: none !important;
    }
    .route-option {
      cursor: pointer;
      transition: all 0.2s;
    }
    .route-option:hover {
      background-color: #f3f4f6;
    }
    .route-option.selected {
      border-left: 4px solid #3b82f6;
      background-color: #f0f7ff;
    }
    .emergency-icon {
      background-color: white;
      border-radius: 50%;
      padding: 5px;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
    }
    .flood-marker {
      border-radius: 50%;
      border: 2px solid white;
    }
    .notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 12px 16px;
      border-radius: 8px;
      color: white;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      z-index: 1000;
      animation: fadeIn 0.3s ease-in;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .fade-out {
      animation: fadeOut 0.5s ease-out;
    }
    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }
    
      #mobile-menu {
          display: none;
      }
  
      .form-container {
          max-width: 450px;
          margin: 0 auto;
      }
  
      .bg-flood-pattern {
          background-image: url('img/flood-pattern.png');
          background-size: cover;
          background-position: center;
          position: relative;
      }
  
      .bg-flood-pattern::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: rgba(246, 59, 131, 0.679); /* Flood overlay */
          z-index: 0;
      }
  
      .form-content {
          position: relative;
          z-index: 1;
      }
  
      @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
      }
  
      @keyframes fadeOut {
          from { opacity: 1; }
          to { opacity: 0; }
      }
  
      .animate-fade-in {
          animation: fadeIn 0.3s ease-in-out;
      }
  
      .animate-fade-out {
          animation: fadeOut 0.5s ease-in-out;
      }
  
      /* Chatbot styles */
      #chat-button {
          background: linear-gradient(135deg, #00bcd4, #2196f3, #f63b83); /* Water to alert tones */
          color: white;
          border: none;
          border-radius: 50px;
          padding: 12px 20px;
          cursor: pointer;
          font-weight: bold;
          transition: all 0.3s ease;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
  
      #chat-button:hover {
          transform: scale(1.05);
      }
  
      #chat-container {
          background: linear-gradient(to bottom right, #e0f7fa, #b2ebf2, #81d4fa); /* Light blue flood theme */
          border-radius: 16px;
          padding: 20px;
          max-width: 400px;
          box-shadow: 0 4px 24px rgba(0, 0, 0, 0.2);
          position: fixed;
          bottom: 100px;
          right: 20px;
          z-index: 1000;
      }
  
      #chat-messages {
          max-height: 300px;
          overflow-y: auto;
          padding-right: 10px;
      }
  
      #chat-messages::-webkit-scrollbar {
          width: 6px;
      }
  
      #chat-messages::-webkit-scrollbar-track {
          background: #f1f1f1;
      }
  
      #chat-messages::-webkit-scrollbar-thumb {
          background-color: #90caf9;
          border-radius: 3px;
      }
  
      .chat-message {
          background-color: #ffffffcc;
          border-radius: 12px;
          padding: 10px 15px;
          margin: 8px 0;
          box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      }
  
      .chat-message.user {
          background-color: #d1c4e9;
          align-self: flex-end;
      }
  
      .chat-message.bot {
          background-color: #e1f5fe;
          align-self: flex-start;
      }
  
  
    /* Turn-by-turn instructions */
.turn-by-turn-container {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: 90%;
  max-width: 500px;
  max-height: 40vh;
  overflow-y: auto;
  background: white;
  border-radius: 12px;
  padding: 15px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  z-index: 1000;
}

.turn-step {
  display: flex;
  padding: 10px 5px;
  border-bottom: 1px solid #f0f0f0;
  align-items: center;
}

.next-step {
  background: #f5f9ff;
  border-left: 3px solid #4285F4;
  margin: 0 -15px;
  padding: 12px 15px !important;
}

.turn-icon {
  font-size: 24px;
  color: #4285F4;
  width: 40px;
  text-align: center;
  margin-right: 12px;
}

.turn-details {
  flex: 1;
}

.turn-instruction {
  font-weight: 500;
  margin-bottom: 3px;
  color: #333;
}

.turn-distance {
  color: #666;
  font-size: 14px;
}

.flood-warning {
  color: #EA4335;
  font-size: 13px;
  margin-top: 5px;
  display: flex;
  align-items: center;
  gap: 5px;
}
  </style>
</head>
<body class="bg-gray-100">
<!-- Navigation Bar -->
<nav class="bg-blue-600 text-white shadow-lg">
  <div class="container mx-auto px-4 py-3 flex justify-between items-center">
    
    <!-- Left Side: Logo and Brand -->
    <div class="flex items-center">
      <!-- Rounded logo holder (bigger) -->
      <div class="h-12 w-12 rounded-full overflow-hidden mr-2">
        <img src="../img/logo.png" alt="FloodSafe Logo" class="h-full w-full object-cover">
      </div>
      
      <!-- Brand Name -->
      <span class="font-bold text-xl">FloodSafe</span>
    </div>

    <!-- Desktop Navigation Links -->
    <div class="hidden md:flex space-x-6">
      <a href="index.html" class="hover:underline">Home</a>
      <a href="navigation.html" class="font-bold underline">Navigation</a>
      <a href="data.html" class="hover:underline">Flood Data</a>
      <a href="about.html" class="hover:underline">About</a>
    </div>

    <!-- Mobile Menu Button -->
    <button id="mobile-menu-btn" class="md:hidden text-2xl focus:outline-none">☰</button>
  </div>

  <!-- Mobile Menu Links -->
  <div id="mobile-menu" class="md:hidden bg-blue-700 px-4 py-2 hidden">
    <a href="index.html" class="block py-2 hover:bg-blue-600 px-2 rounded">Home</a>
    <a href="navigation.html" class="block py-2 hover:bg-blue-600 px-2 rounded font-bold">Navigation</a>
    <a href="data.html" class="block py-2 hover:bg-blue-600 px-2 rounded">Flood Data</a>
    <a href="about.html" class="block py-2 hover:bg-blue-600 px-2 rounded">About</a>
  </div>
</nav>
  
  <!-- Main Content -->
  <main class="container mx-auto p-4 max-w-4xl">
    <h1 class="text-2xl font-bold text-center mb-6">Flood-Safe Route Planner</h1>

    <!-- Smart Routing Card - ML Integration -->
  <div class="bg-white rounded-lg shadow-md p-4 mb-4">
    <h2 class="text-xl font-bold mb-3 flex items-center">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2 text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
      </svg>
      Smart Routing
    </h2>
    <div class="text-sm text-gray-600 mb-4">
      AI-powered route planning that considers current flood data, traffic conditions, and predicted weather changes.
    </div>
    
    <div class="flex items-center mb-4">
      <div class="mr-2 font-medium">Prioritize:</div>
      <div class="flex space-x-2">
        <button id="priority-fastest" class="px-3 py-1 bg-blue-600 text-white rounded-md text-sm">Fastest</button>
        <button id="priority-safest" class="px-3 py-1 bg-gray-200 text-gray-700 rounded-md text-sm">Safest</button>
        <button id="priority-balanced" class="px-3 py-1 bg-gray-200 text-gray-700 rounded-md text-sm">Balanced</button>
      </div>
    </div>
    
    <div id="ml-route-stats" class="grid grid-cols-3 gap-4 mb-4">
      <div class="text-center p-2 bg-gray-50 rounded">
        <div class="text-sm text-gray-600">Estimated Time</div>
        <div id="ml-route-time" class="font-bold">24 min</div>
      </div>
      <div class="text-center p-2 bg-gray-50 rounded">
        <div class="text-sm text-gray-600">Distance</div>
        <div id="ml-route-distance" class="font-bold">5.2 km</div>
      </div>
      <div class="text-center p-2 bg-gray-50 rounded">
        <div class="text-sm text-gray-600">Safety Score</div>
        <div id="ml-route-safety" class="font-bold text-yellow-600">7/10</div>
      </div>
    </div>
    
    <div class="text-sm text-gray-600">
      <span class="font-medium">AI Insight:</span>
      <span id="ml-route-insight">This route avoids 3 flood-prone areas and 1 road with heavy traffic. Alternative routes available.</span>
    </div>
  </div>
    
    <!-- Transport Mode Selector -->
    <div class="flex justify-center gap-2 mb-4">
      <button id="driveMode" class="transport-mode active px-4 py-2 rounded-lg border border-gray-300 flex items-center">
        <i class="fas fa-car mr-2"></i> Drive
      </button>
      <button id="walkMode" class="transport-mode px-4 py-2 rounded-lg border border-gray-300 flex items-center">
        <i class="fas fa-walking mr-2"></i> Walk
      </button>
      <button id="motorcycleMode" class="transport-mode px-4 py-2 rounded-lg border border-gray-300 flex items-center">
        <i class="fas fa-motorcycle mr-2"></i> Motorcycle
      </button>
    </div>
    
    <!-- Location Controls -->
    <div class="flex gap-2 mb-6 justify-center">
      <button id="useMyLocation" class="bg-green-600 text-white px-4 py-2 rounded-lg shadow hover:bg-green-700 transition flex items-center">
        <i class="fas fa-location-arrow mr-2"></i> Use My Device Location
      </button>
      <button id="showEmergency" class="bg-red-600 text-white px-4 py-2 rounded-lg shadow hover:bg-red-700 transition flex items-center">
        <i class="fas fa-exclamation-triangle mr-2"></i> Emergency Services
      </button>
    </div>

    <!-- Location Risk Indicator -->
    <div id="locationRiskCard" class="hidden bg-white p-4 rounded-lg shadow-md mb-4 border-l-4">
      <div class="flex items-center">
        <div id="riskIcon" class="text-2xl mr-3"></div>
        <div>
          <h3 class="font-bold" id="riskTitle">Risk Assessment</h3>
          <p class="text-sm text-gray-600" id="riskDetails">Checking location safety...</p>
        </div>
      </div>
      <div id="riskHotspots" class="mt-2 hidden">
        <div class="text-xs font-semibold text-gray-500 mb-1">NEARBY FLOODS:</div>
        <div class="space-y-1" id="hotspotList"></div>
      </div>
    </div>

    <!-- Route Input with Autocomplete -->
    <div class="bg-white p-6 rounded-lg shadow-md mb-8">
      <div class="grid grid-cols-1 gap-4">
        <div>
          <label for="startInput" class="block font-medium mb-1">Start Location</label>
          <div class="relative">
            <input id="startInput" type="text" placeholder="Search place..." 
                  class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
            <div id="startSuggestions" class="absolute hidden w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg"></div>
          </div>
          <div id="startRisk" class="risk-indicator hidden mt-1 text-xs p-2 rounded"></div>
        </div>
        <div>
          <label for="endInput" class="block font-medium mb-1">Destination</label>
          <div class="relative">
            <input id="endInput" type="text" placeholder="Search place..." 
                  class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
            <div id="endSuggestions" class="absolute hidden w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg"></div>
          </div>
          <div id="endRisk" class="risk-indicator hidden mt-1 text-xs p-2 rounded"></div>
        </div>
        <button id="calculateRoute" class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-3 px-6 rounded-lg transition flex items-center justify-center">
          <i class="fas fa-route mr-2"></i> Calculate Safest Route
        </button>
      </div>
    </div>

    <!-- Map Container -->
    <div class="relative mb-8">
      <div id="floodMap"></div>
    </div>
    
    <!-- Route Options -->
    <div id="routeOptions" class="hidden bg-white p-4 rounded-lg shadow-md mb-4">
      <h3 class="font-bold mb-2">Route Options</h3>
      <div id="routeOptionsList" class="space-y-2"></div>
    </div>
    
    <!-- Route Information -->
    <div id="routeInfo" class="bg-white p-4 rounded-lg shadow-md hidden">
      <div class="flex justify-between items-center mb-2">
        <h3 class="font-bold">Route Information</h3>
        <button id="voiceToggle" class="text-blue-600 text-sm flex items-center">
          <i class="fas fa-volume-up mr-1"></i> Voice Guidance
        </button>
      </div>
      <div class="grid grid-cols-3 gap-4 text-sm mb-3">
        <div>
          <span class="text-gray-500">Distance:</span>
          <span id="routeDistance" class="font-medium">-</span>
        </div>
        <div>
          <span class="text-gray-500">Duration:</span>
          <span id="routeDuration" class="font-medium">-</span>
        </div>
        <div>
          <span class="text-gray-500">Flood Risk:</span>
          <span id="routeRisk" class="font-medium">-</span>
        </div>
      </div>
      <div id="navigationInstructions" class="text-sm space-y-2"></div>
    </div>
    <div id="turnByTurnContainer" class="turn-by-turn-instructions"></div>

    <!-- Add this near the top of your main content section -->
<div id="flood-alert" class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded mb-4 hidden">
  <div class="flex">
      <div class="flex-shrink-0">
          <svg class="h-5 w-5 text-red-700" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
          </svg>
      </div>
      <div class="ml-3">
          <p class="text-sm font-medium alert-text">
              Severe flooding reported in your area. Please stay safe and avoid flood-prone routes.
          </p>
      </div>
  </div>
</div>


  </main>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <!-- new additional for backend -->
  <script src="../script/flood-detection.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Wait until Leaflet and all scripts are loaded
        setTimeout(function() {
            if (typeof FloodMap !== 'undefined' && document.getElementById('floodMap')) {
                try {
                    const detector = new FloodMap();
                    detector.init();
                } catch(e) {
                    console.error("Initialization failed:", e);
                }
            } else {
                console.log("FloodMap not defined or map element missing");
            }
        }, 100); // Small delay to ensure everything is loaded
    });
    </script>
    <script>
      // ====== YOUR ORIGINAL VARIABLES (with 2 critical additions) ======
      let floodMap;
      let floodLayer = L.layerGroup();
      let routeLayer = L.layerGroup();
      let riskRadiusLayer = L.layerGroup();
      let emergencyLayer = L.layerGroup();
      let currentRoute = null;
      let currentLocationMarker;
      let floodCache = new Map();
      let transportMode = 'drive'; // 'drive', 'walk', 'motorcycle'
      let voiceGuidance = false;
      let speechSynthesis = window.speechSynthesis;
      let emergencyData = [];
      let alternativeRoutes = [];
      let selectedRouteIndex = 0;
      let currentStepIndex = 0; // Tracks which step in the route you're on
      let nextTurnMarker = null; // Single marker for next turn indicator
      // Flood marker coordinates
      const FLOOD_MARKERS = [
        { name: "Carmona-Timbao Road", lat: 14.31147, lng: 121.06403, water_level: 80 },
        { name: "Corner South City Drive", lat: 14.32477, lng: 121.07339, water_level: 60 },
        { name: "Corner South Plains", lat: 14.32513, lng: 121.07537, water_level: 45 },
        { name: "La Consolacion College", lat: 14.32672, lng: 121.07759, water_level: 30 },
        { name: "Brgy Hall Extension", lat: 14.32751, lng: 121.07809, water_level: 25 }
      ];
  
      // Risk levels configuration
      const RISK_LEVELS = {
        low: {
          color: '#10B981',
          icon: 'fa-circle-check',
          title: 'Low Risk'
        },
        moderate: {
          color: '#F59E0B',
          icon: 'fa-triangle-exclamation',
          title: 'Moderate Risk'
        },
        high: {
          color: '#EF4444',
          icon: 'fa-circle-exclamation',
          title: 'High Risk'
        }
      };
  
      // Emergency service icons
      const EMERGENCY_ICONS = {
        'barangay_hall': { icon: 'fa-landmark', color: '#3B82F6' },
        'police_station': { icon: 'fa-shield-alt', color: '#1D4ED8' },
        'fire_station': { icon: 'fa-fire-extinguisher', color: '#DC2626' },
        'evacuation_center': { icon: 'fa-home', color: '#10B981' }
      };
  
      // ====== TURN-BY-TURN FUNCTIONS ======
      function displayTurnByTurnInstructions(steps) {
        try {
            const container = document.getElementById('turnByTurnContainer');
            if (!container) throw new Error('Container element not found');
            if (!steps || !Array.isArray(steps)) throw new Error('Invalid steps data');
            
            container.innerHTML = '';
            
            steps.forEach((step, index) => {
                if (index === 0) return;
                
                if (!step.maneuver) {
                    console.warn('Missing maneuver data for step', step);
                    return;
                }
                
                const stepElement = document.createElement('div');
                stepElement.className = `turn-step ${index === 1 ? 'next-step' : ''}`;
                
                const icon = getManeuverIcon(step.maneuver);
                const distance = formatDistance(step.distance);
                
                stepElement.innerHTML = `
                    <div class="turn-icon">${icon}</div>
                    <div class="turn-details">
                        <div class="turn-instruction">${step.maneuver.instruction || 'Continue'}</div>
                        <div class="turn-distance">${distance}</div>
                        ${step.hasFlood ? '<div class="flood-warning">⚠️ Flood warning</div>' : ''}
                    </div>
                `;
                container.appendChild(stepElement);
            });
        } catch (error) {
            console.error('Error displaying instructions:', error);
        }
      }
  
      // 2. INITIALIZATION ================================================
      document.addEventListener('DOMContentLoaded', function() {
        // Initialize the map
        initMap();
        
        // Load initial data
        loadInitialFloodData();
        loadEmergencyData();
        
        // Set up event listeners
        initEventListeners();
        
        // Check for voice support
        if ('speechSynthesis' in window) {
          document.getElementById('voiceToggle').classList.remove('hidden');
        }
      });
  
      // Initialize the map
      function initMap() {
        try {
          // Create map centered on a default location (Biñan, Laguna)
          floodMap = L.map('floodMap').setView([14.3036, 121.0781], 13);
  
          // Add OpenStreetMap base layer
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            maxZoom: 19
          }).addTo(floodMap);
  
          // Initialize layer groups
          floodLayer.addTo(floodMap);
          routeLayer.addTo(floodMap);
          riskRadiusLayer.addTo(floodMap);
          emergencyLayer.addTo(floodMap);
  
          // Add scale control
          L.control.scale().addTo(floodMap);
  
        } catch (error) {
          console.error("Map initialization error:", error);
          showNotification("Failed to initialize map. Please refresh the page.", "error");
        }
      }
  
      // Load initial flood data
      function loadInitialFloodData() {
        // For demo purposes, we'll use mock data
        // In a real app, you would fetch this from an API
        const mockFloodData = [
          { id: 1, latitude: 14.31147, longitude: 121.06403, water_level: 85, timestamp: new Date().toISOString() }, // Carmona-Timbao Road
          { id: 2, latitude: 14.32477, longitude: 121.07339, water_level: 65, timestamp: new Date().toISOString() }, // Corner South City Drive
          { id: 3, latitude: 14.32513, longitude: 121.07537, water_level: 45, timestamp: new Date().toISOString() }, // Corner South Plains
          { id: 4, latitude: 14.32672, longitude: 121.07759, water_level: 30, timestamp: new Date().toISOString() }, // La Consolacion College
          { id: 5, latitude: 14.32751, longitude: 121.07809, water_level: 70, timestamp: new Date().toISOString() }  // Brgy Hall Extension
        ];
     
        updateFloodData(mockFloodData);
      }
  
      // Load emergency data
      function loadEmergencyData() {
        // Mock emergency service locations
        emergencyData = [
          { type: 'barangay_hall', name: 'Barangay Hall 1', lat: 14.31150, lng: 121.06392 },
          { type: 'barangay_hall', name: 'Barangay Hall 2', lat: 14.32765, lng: 121.07813 },
          { type: 'police_station', name: 'Police Station', lat: 14.31672, lng: 121.07945 },
          { type: 'fire_station', name: 'Fire Station', lat: 14.31828, lng: 121.06124 },
          { type: 'evacuation_center', name: 'Evacuation Center', lat: 14.31400, lng: 121.06689 }
        ];
      }
  
      // Initialize event listeners
      function initEventListeners() {
        // Mobile menu toggle
        document.getElementById('mobile-menu-btn').addEventListener('click', function() {
          const menu = document.getElementById('mobile-menu');
          menu.classList.toggle('hidden');
        });
  
        // Transport mode buttons
        document.getElementById('driveMode').addEventListener('click', () => setTransportMode('drive'));
        document.getElementById('walkMode').addEventListener('click', () => setTransportMode('walk'));
        document.getElementById('motorcycleMode').addEventListener('click', () => setTransportMode('motorcycle'));
  
        // Input change listeners with autocomplete
        setupAutocomplete('startInput', 'startSuggestions');
        setupAutocomplete('endInput', 'endSuggestions');
  
        // Input safety check
        document.getElementById('startInput').addEventListener('change', () => checkInputSafety('startInput'));
        document.getElementById('endInput').addEventListener('change', () => checkInputSafety('endInput'));
  
        // Calculate route button
        document.getElementById('calculateRoute').addEventListener('click', calculateSafeRoute);
  
        // Use my location button
        document.getElementById('useMyLocation').addEventListener('click', handleLocationClick);
  
        // Emergency services button
        document.getElementById('showEmergency').addEventListener('click', toggleEmergencyServices);
  
        // Voice toggle button
        document.getElementById('voiceToggle').addEventListener('click', toggleVoiceGuidance);
      }
  
      // Set up autocomplete for an input field
      function setupAutocomplete(inputId, suggestionsId) {
        const input = document.getElementById(inputId);
        const suggestions = document.getElementById(suggestionsId);
        
        input.addEventListener('input', debounce(async () => {
          const query = input.value.trim();
          if (query.length < 3) {
            suggestions.classList.add('hidden');
            return;
          }
          
          try {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5`);
            const data = await response.json();
            
            suggestions.innerHTML = '';
            
            if (data.length > 0) {
              data.forEach(item => {
                const div = document.createElement('div');
                div.className = 'p-2 hover:bg-gray-100 cursor-pointer';
                div.textContent = item.display_name;
                div.addEventListener('click', () => {
                  input.value = item.display_name;
                  suggestions.classList.add('hidden');
                  checkInputSafety(inputId);
                });
                suggestions.appendChild(div);
              });
              suggestions.classList.remove('hidden');
            } else {
              suggestions.classList.add('hidden');
            }
          } catch (error) {
            console.error("Autocomplete error:", error);
            suggestions.classList.add('hidden');
          }
        }, 300));
        
        // Hide suggestions when clicking elsewhere
        document.addEventListener('click', (e) => {
          if (e.target.id !== inputId && !suggestions.contains(e.target)) {
            suggestions.classList.add('hidden');
          }
        });
      }
  
      // Geocode address using OpenStreetMap Nominatim API
      async function geocodeAddress(address) {
        try {
          const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`);
          const data = await response.json();
          if (data.length > 0) {
            return {
              lat: parseFloat(data[0].lat),
              lng: parseFloat(data[0].lon)
            };
          }
          return null;
        } catch (error) {
          console.error("Geocoding error:", error);
          return null;
        }
      }
  
      // Set transport mode
      function setTransportMode(mode) {
        transportMode = mode;
        
        // Update UI
        document.querySelectorAll('.transport-mode').forEach(btn => {
          btn.classList.remove('active');
        });
        document.getElementById(`${mode}Mode`).classList.add('active');
        
        // Recalculate route if one exists
        if (currentRoute) {
          calculateSafeRoute();
        }
      }
  
      // Toggle emergency services display
      function toggleEmergencyServices() {
        if (emergencyLayer.getLayers().length === 0) {
          plotEmergencyServices();
          document.getElementById('showEmergency').innerHTML = '<i class="fas fa-eye-slash mr-2"></i> Hide Services';
        } else {
          emergencyLayer.clearLayers();
          document.getElementById('showEmergency').innerHTML = '<i class="fas fa-exclamation-triangle mr-2"></i> Emergency Services';
        }
      }
  
      // Plot emergency services on map
      function plotEmergencyServices() {
        emergencyLayer.clearLayers();
        
        emergencyData.forEach(service => {
          const iconInfo = EMERGENCY_ICONS[service.type];
          if (!iconInfo) return;
          
          const marker = L.marker([service.lat, service.lng], {
            icon: L.divIcon({
              className: 'emergency-marker',
              html: `<div class="emergency-icon" style="color: ${iconInfo.color}">
                      <i class="fas ${iconInfo.icon}"></i>
                    </div>`,
              iconSize: [30, 30]
            })
          }).bindPopup(`
            <b>${service.name}</b><br>
            <span style="color: ${iconInfo.color}">
              <i class="fas ${iconInfo.icon}"></i> ${service.type.replace('_', ' ').toUpperCase()}
            </span>
          `);
          
          emergencyLayer.addLayer(marker);
        });
        
        // Fit map to show all emergency services
        if (emergencyData.length > 0) {
          const bounds = L.latLngBounds(emergencyData.map(s => [s.lat, s.lng]));
          floodMap.fitBounds(bounds, { padding: [50, 50] });
        }
      }
  
      // Update flood data on map
      function updateFloodData(floodData) {
        floodLayer.clearLayers();
        
        floodData.forEach(sensor => {
          const severity = getSeverity(sensor.water_level);
          const marker = L.circleMarker([sensor.latitude, sensor.longitude], {
            radius: 6 + (sensor.water_level / 20),
            color: '#fff',
            weight: 1,
            fillColor: RISK_LEVELS[severity].color,
            fillOpacity: 0.7,
            className: 'flood-marker'
          }).bindPopup(`
            <b>${sensor.name || 'Flood Sensor #'+sensor.id}</b><br>
            Water Level: ${sensor.water_level} cm<br>
            Status: <span style="color: ${RISK_LEVELS[severity].color}">${severity.toUpperCase()}</span>
          `);
          
          floodLayer.addLayer(marker);
        });
      }
  
      // Toggle voice guidance
      function toggleVoiceGuidance() {
        voiceGuidance = !voiceGuidance;
        const button = document.getElementById('voiceToggle');
        
        if (voiceGuidance) {
          button.innerHTML = '<i class="fas fa-volume-mute mr-1"></i> Mute Guidance';
          speak("Voice guidance activated");
          
          // Speak initial instructions if route exists
          if (currentRoute) {
            speakNavigationInstructions(currentRoute.legs[0].steps);
          }
        } else {
          button.innerHTML = '<i class="fas fa-volume-up mr-1"></i> Voice Guidance';
          speechSynthesis.cancel();
        }
      }
  
      // Speak text
      function speak(text) {
        if (!voiceGuidance) return;
        
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1.0;
        utterance.pitch = 1.0;
        speechSynthesis.speak(utterance);
      }
  
      // Handle location button click
      async function handleLocationClick() {
        if (!navigator.geolocation) {
          showNotification("Geolocation is not supported by your browser", "error");
          return;
        }
  
        const locationBtn = document.getElementById('useMyLocation');
        locationBtn.disabled = true;
        locationBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Locating...';
  
        try {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 0
            });
          });
  
          const { latitude, longitude } = position.coords;
          
          // Center map on user's location
          floodMap.setView([latitude, longitude], 15);
          
          // Add/update marker
          if (currentLocationMarker) {
            currentLocationMarker.setLatLng([latitude, longitude]);
          } else {
            currentLocationMarker = L.marker([latitude, longitude], {
              icon: L.divIcon({
                className: 'user-location-marker',
                html: '<i class="fas fa-circle-dot text-blue-600 text-2xl"></i>',
                iconSize: [30, 30]
              })
            }).addTo(floodMap)
            .bindPopup("Your Location");
          }
          
          // Set the start input with coordinates
          document.getElementById('startInput').value = `${latitude.toFixed(5)}, ${longitude.toFixed(5)}`;
          showNotification(`Using your current location: ${latitude.toFixed(5)}, ${longitude.toFixed(5)}`, "success");
          checkInputSafety('startInput');
        } catch (error) {
          let errorMsg = "Error getting location: ";
          switch(error.code) {
            case error.PERMISSION_DENIED:
              errorMsg += "Permission denied";
              break;
            case error.POSITION_UNAVAILABLE:
              errorMsg += "Position unavailable";
              break;
            case error.TIMEOUT:
              errorMsg += "Request timed out";
              break;
            default:
              errorMsg += "Unknown error";
          }
          showNotification(errorMsg, "error");
        } finally {
          locationBtn.innerHTML = '<i class="fas fa-location-arrow mr-2"></i> Use My Device Location';
          locationBtn.disabled = false;
        }
      }
  
 // Replace the generateGoogleMapsLikeRoutes function with this OSRM-based version
async function generateOSRMRoutes(start, end) {
  try {
      // OSRM API endpoint (you can host your own instance for production)
      const osrmUrl = `https://router.project-osrm.org/route/v1/driving/` +
                     `${start.lng},${start.lat};${end.lng},${end.lat}?overview=full&steps=true&alternatives=true`;
      
      const response = await fetch(osrmUrl);
      const data = await response.json();
      
      if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
          throw new Error('No route found');
      }
      
      // Process all alternative routes
      const routes = data.routes.map((osrmRoute, index) => {
          // Convert coordinates to Leaflet's LatLng format (OSRM uses [lng,lat])
          const path = osrmRoute.geometry.coordinates.map(coord => [coord[1], coord[0]]);
          
          // Process steps for turn-by-turn navigation
          const steps = osrmRoute.legs[0].steps.map(step => {
              return {
                  instruction: step.maneuver.instruction,
                  distance: step.distance,
                  duration: step.duration,
                  maneuver: step.maneuver,
                  hasFlood: false // Will be updated by flood detection
              };
          });
          
          // Check for flood risks along this route
          const floodCheck = checkRouteForFloods(path);
          
          return {
              distance: osrmRoute.distance,
              duration: osrmRoute.duration,
              geometry: {
                  coordinates: osrmRoute.geometry.coordinates,
                  type: "LineString"
              },
              legs: [{
                  steps: steps,
                  summary: osrmRoute.legs[0].summary,
                  distance: osrmRoute.legs[0].distance,
                  duration: osrmRoute.legs[0].duration
              }],
              hasFlood: floodCheck.hasFlood,
              riskLevel: floodCheck.highestSeverity,
              instructions: steps, // For voice navigation
              origin: document.getElementById('startInput').value,
              destination: document.getElementById('endInput').value
          };
      });
      
      return routes;
  } catch (error) {
      console.error('Error generating OSRM route:', error);
      
      // Fallback to mock data if OSRM fails
      return generateMockRoutes(start, end);
  }
}

// Helper function to check route for flood risks
function checkRouteForFloods(path) {
  let hasFlood = false;
  let highestSeverity = 'low';
  
  // Sample points along the route to check for floods
  for (let i = 0; i < path.length; i += Math.floor(path.length / 20)) {
      const point = path[i];
      const nearbyFloods = getNearbyFloods(point[0], point[1], 200); // 200m radius
      
      nearbyFloods.forEach(flood => {
          const severity = getSeverity(flood.water_level);
          hasFlood = true;
          
          if (severity === 'high' && highestSeverity !== 'high') {
              highestSeverity = 'high';
          } else if (severity === 'moderate' && highestSeverity === 'low') {
              highestSeverity = 'moderate';
          }
      });
  }
  
  return { hasFlood, highestSeverity };
}

// Fallback mock data generator (similar to your original)
function generateMockRoutes(start, end) {
  // Common streets in Biñan City, Laguna (Brgy. Sto Tomas)
  const streets = [
      "Sto. Tomas Street",
      "G. Leviste Street",
      "M. L. Quezon Avenue",
      "P. Burgos Street",
      "Rizal Avenue",
      "Sampaguita Street",
      "Narra Street",
      "Mahogany Street",
      "Acacia Street",
      "Santol Street"
  ];

  // Calculate midpoint between start and end
  const midLat = (start.lat + end.lat) / 2;
  const midLng = (start.lng + end.lng) / 2;
  
  // Create 3 different realistic route options with multiple turns
  return [
      // Route 1: Shortest path (may have flood risk)
      {
          distance: 3500,
          duration: 900,
          geometry: {
              type: "LineString",
              coordinates: [
                  [start.lng, start.lat], // Start point
                  [start.lng + 0.0015, start.lat + 0.001], // First turn
                  [midLng + 0.001, midLat + 0.0005], // Midpoint adjustment
                  [end.lng - 0.0015, end.lat - 0.0005], // Approach to destination
                  [end.lng, end.lat] // End point
              ]
          },
          legs: [
              {
                  steps: [
                      { instruction: `Head northeast on ${streets[0]}`, distance: 500, duration: 120 },
                      { instruction: `Turn right onto ${streets[1]}`, distance: 800, duration: 240 },
                      { instruction: `Continue straight on ${streets[2]}`, distance: 1200, duration: 300 },
                      { instruction: `Turn left onto ${streets[3]}`, distance: 1000, duration: 240 }
                  ]
              }
          ],
          hasFlood: true,
          riskLevel: 'high',
          origin: document.getElementById('startInput').value,
          destination: document.getElementById('endInput').value
      },
      // Route 2: Longer but safer path
      {
          distance: 4200,
          duration: 1100,
          geometry: {
              type: "LineString",
              coordinates: [
                  [start.lng, start.lat], // Start point
                  [start.lng - 0.001, start.lat - 0.0005], // First turn
                  [midLng - 0.0015, midLat - 0.0005], // Midpoint adjustment
                  [midLng - 0.001, midLat + 0.0015], // Second midpoint adjustment
                  [end.lng + 0.001, end.lat + 0.0005], // Approach to destination
                  [end.lng, end.lat] // End point
              ]
          },
          legs: [
              {
                  steps: [
                      { instruction: `Head southwest on ${streets[4]}`, distance: 600, duration: 150 },
                      { instruction: `Turn left onto ${streets[5]}`, distance: 1000, duration: 250 },
                      { instruction: `Turn right onto ${streets[6]}`, distance: 1500, duration: 375 },
                      { instruction: `Continue straight on ${streets[7]}`, distance: 1100, duration: 325 }
                  ]
              }
          ],
          hasFlood: false,
          riskLevel: 'low',
          origin: document.getElementById('startInput').value,
          destination: document.getElementById('endInput').value
      },
      // Route 3: Balanced option
      {
          distance: 3800,
          duration: 950,
          geometry: {
              type: "LineString",
              coordinates: [
                  [start.lng, start.lat], // Start point
                  [start.lng + 0.0005, start.lat + 0.0005], // First turn
                  [midLng + 0.002, midLat - 0.001], // Midpoint adjustment
                  [midLng + 0.0015, midLat + 0.0005], // Second midpoint adjustment
                  [end.lng - 0.0005, end.lat - 0.0005], // Approach to destination
                  [end.lng, end.lat] // End point
              ]
          },
          legs: [
              {
                  steps: [
                      { instruction: `Head northeast on ${streets[8]}`, distance: 700, duration: 175 },
                      { instruction: `Turn left onto ${streets[9]}`, distance: 1200, duration: 300 },
                      { instruction: `Turn right onto ${streets[1]}`, distance: 1000, duration: 250 },
                      { instruction: `Continue straight on ${streets[2]}`, distance: 900, duration: 225 }
                  ]
              }
          ],
          hasFlood: false,
          riskLevel: 'low',
          origin: document.getElementById('startInput').value,
          destination: document.getElementById('endInput').value
      }
  ];
}

// Then modify your calculateSafeRoute function to use the new OSRM function:
async function calculateSafeRoute() {
  const startInput = document.getElementById('startInput').value;
  const endInput = document.getElementById('endInput').value;

  if (!startInput || !endInput) {
      showNotification("Please enter both start and destination locations", "error");
      return;
  }

  try {
      showNotification("Calculating safest route...", "info");
      
      // Try to parse as coordinates first
      const coordRegex = /^(-?\d+\.\d+),\s*(-?\d+\.\d+)$/;
      const startMatch = startInput.match(coordRegex);
      const endMatch = endInput.match(coordRegex);
      
      let startCoords, endCoords;
      
      if (startMatch) {
          startCoords = { lat: parseFloat(startMatch[1]), lng: parseFloat(startMatch[2]) };
      } else {
          // Geocode the start address
          const startGeocode = await geocodeAddress(startInput);
          if (!startGeocode) throw new Error("Could not find start location");
          startCoords = startGeocode;
      }
      
      if (endMatch) {
          endCoords = { lat: parseFloat(endMatch[1]), lng: parseFloat(endMatch[2]) };
      } else {
          // Geocode the end address
          const endGeocode = await geocodeAddress(endInput);
          if (!endGeocode) throw new Error("Could not find destination");
          endCoords = endGeocode;
      }
      
      // Get routes from OSRM
      alternativeRoutes = await generateOSRMRoutes(startCoords, endCoords);
      
      if (!alternativeRoutes || alternativeRoutes.length === 0) {
          throw new Error("No routes found");
      }

      selectedRouteIndex = 0;
      currentRoute = alternativeRoutes[selectedRouteIndex];
      
      // Display route options
      displayRouteOptions();
      
      // Show the first route
      displayRoute(currentRoute);
      
      // Show route info
      document.getElementById('routeInfo').classList.remove('hidden');
      document.getElementById('routeOptions').classList.remove('hidden');
      document.getElementById('routeDistance').textContent = (currentRoute.distance / 1000).toFixed(1) + ' km';
      document.getElementById('routeDuration').textContent = formatDuration(currentRoute.duration);
      document.getElementById('routeRisk').textContent = currentRoute.hasFlood ? 'HIGH' : 'LOW';
      document.getElementById('routeRisk').className = `font-medium ${currentRoute.hasFlood ? 'text-red-600' : 'text-green-600'}`;
      
      showNotification("Route calculated successfully", "success");
      
      // Speak instructions if voice guidance is on
      if (voiceGuidance) {
          speak("Route calculated. " + getRouteSummary(currentRoute));
          setTimeout(() => speakNavigationInstructions(currentRoute.legs[0].steps), 1000);
      } else {
          // Still show turn list even if voice is off
          displayTurnByTurnInstructions(currentRoute.legs[0].steps);
      }
  } catch (error) {
      console.error("Route calculation error:", error);
      showNotification("Could not calculate route: " + error.message, "error");
      if (voiceGuidance) {
          speak("Sorry, I couldn't calculate the route. Please try again.");
      }
  }
}
      // Calculate safe route with alternative options
      async function calculateSafeRoute() {
        const startInput = document.getElementById('startInput').value;
        const endInput = document.getElementById('endInput').value;
  
        if (!startInput || !endInput) {
            showNotification("Please enter both start and destination locations", "error");
            return;
        }
  
        try {
            showNotification("Calculating safest route...", "info");
            
            // For demo purposes, we'll use mock routes
            let startCoords, endCoords;
            
            // Try to parse as coordinates first
            const coordRegex = /^(-?\d+\.\d+),\s*(-?\d+\.\d+)$/;
            const startMatch = startInput.match(coordRegex);
            const endMatch = endInput.match(coordRegex);
            
            if (startMatch) {
                startCoords = { lat: parseFloat(startMatch[1]), lng: parseFloat(startMatch[2]) };
            } else {
                // Geocode the start address
                const startGeocode = await geocodeAddress(startInput);
                if (!startGeocode) throw new Error("Could not find start location");
                startCoords = startGeocode;
            }
            
            if (endMatch) {
                endCoords = { lat: parseFloat(endMatch[1]), lng: parseFloat(endMatch[2]) };
            } else {
                // Geocode the end address
                const endGeocode = await geocodeAddress(endInput);
                if (!endGeocode) throw new Error("Could not find destination");
                endCoords = endGeocode;
            }
            
            // Get OSRM route with alternatives
            const response = await fetch(
                `http://router.project-osrm.org/route/v1/driving/` +
                `${startCoords.lng},${startCoords.lat};${endCoords.lng},${endCoords.lat}?` +
                `overview=full&geometries=geojson&alternatives=true`
            );
  
            const routeData = await response.json();
  
            if (routeData.code !== "Ok") {
                throw new Error(routeData.message || "Routing failed");
            }
  
            // Process all alternative routes
            alternativeRoutes = routeData.routes.map((osrmRoute, index) => ({
                geometry: {
                    coordinates: osrmRoute.geometry.coordinates
                },
                distance: osrmRoute.distance,
                duration: osrmRoute.duration,
                legs: [{
                    steps: osrmRoute.legs[0].steps
                }],
                isSelected: index === 0,
                hasFlood: false, // You'll need to implement flood detection
                riskLevel: 'LOW',
                instructions: osrmRoute.legs[0].steps // For voice navigation
            }));
  
            selectedRouteIndex = 0;
            currentRoute = alternativeRoutes[selectedRouteIndex];
            
            // Display route options
            displayRouteOptions();
            
            // Show the first route
            displayRoute(currentRoute);
            
            // Show route info
            document.getElementById('routeInfo').classList.remove('hidden');
            document.getElementById('routeOptions').classList.remove('hidden');
            document.getElementById('routeDistance').textContent = (currentRoute.distance / 1000).toFixed(1) + ' km';
            document.getElementById('routeDuration').textContent = formatDuration(currentRoute.duration);
            document.getElementById('routeRisk').textContent = currentRoute.hasFlood ? 'HIGH' : 'LOW';
            document.getElementById('routeRisk').className = `font-medium ${currentRoute.hasFlood ? 'text-red-600' : 'text-green-600'}`;
            
            showNotification("Route calculated successfully", "success");
            
            // Speak instructions if voice guidance is on
            if (voiceGuidance) {
                speak("Route calculated. " + getRouteSummary(currentRoute));
                setTimeout(() => speakNavigationInstructions(currentRoute.legs[0].steps), 1000);
            } else {
              // Still show turn list even if voice is off
              displayTurnByTurnInstructions(currentRoute.legs[0].steps);
            }
        } catch (error) {
            console.error("Route calculation error:", error);
            showNotification("Could not calculate route: " + error.message, "error");
            if (voiceGuidance) {
                speak("Sorry, I couldn't calculate the route. Please try again.");
            }
        }
      }
  
      function displayRoute(route) {
        routeLayer.clearLayers();
        
        // Handle both OSRM and legacy coordinate formats
        const coords = route.coordinates || (route.geometry && route.geometry.coordinates) || [];
        if (coords.length === 0) {
            console.error("Invalid route data:", route);
            return;
        }
        
        // Convert coordinates to Leaflet's LatLng format (OSRM uses [lng,lat])
        const latLngs = coords.map(coord => [coord[1], coord[0]]);
        
        // 1. Route Visualization ==============================================
        
        // White border effect (Google Maps style)
        L.polyline(latLngs, {
            color: '#ffffff',
            weight: 9,
            opacity: 0.7,
            smoothFactor: 1.0,
            lineJoin: 'round',
            lineCap: 'round'
        }).addTo(routeLayer);
        
        // Main route line with conditional coloring
        const routeLine = L.polyline(latLngs, {
            color: route.hasFlood ? '#EA4335' : '#4285F4', // Red for flood, blue for safe
            weight: 5,
            opacity: 0.9,
            smoothFactor: 1.0,
            lineJoin: 'round',
            lineCap: 'round'
        }).addTo(routeLayer);
        
        // Animated dash effect for selected route
        if (route.isSelected) {
            const animatedDash = L.polyline(latLngs, {
                color: '#4285F4',
                weight: 3,
                opacity: 0.8,
                dashArray: '10, 15',
                dashOffset: 0,
                smoothFactor: 1.0,
                lineJoin: 'round',
                lineCap: 'round'
            }).addTo(routeLayer);
            
            // Animation loop
            let dashOffset = 0;
            const animateDash = () => {
                dashOffset -= 1;
                animatedDash.setStyle({ dashOffset });
                requestAnimationFrame(animateDash);
            };
            animateDash();
        }
        
        // 2. Markers ========================================================
        
        // Enhanced start marker (Google Maps green)
        L.marker(latLngs[0], {
            icon: L.divIcon({ 
                className: 'start-marker', 
                html: `
                    <div class="start-marker-inner" 
                         style="background-color: #34A853; 
                                width: 24px; 
                                height: 24px; 
                                border-radius: 50%; 
                                display: flex; 
                                align-items: center; 
                                justify-content: center; 
                                box-shadow: 0 2px 6px rgba(0,0,0,0.3);">
                        <i class="fas fa-location-dot text-white"></i>
                    </div>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            })
        }).addTo(routeLayer).bindPopup("Start Point");
        
        // Enhanced end marker (Google Maps red)
        L.marker(latLngs[latLngs.length - 1], {
            icon: L.divIcon({ 
                className: 'end-marker',
                html: `
                    <div class="end-marker-inner" 
                         style="background-color: #EA4335; 
                                width: 24px; 
                                height: 24px; 
                                border-radius: 50%; 
                                display: flex; 
                                align-items: center; 
                                justify-content: center; 
                                box-shadow: 0 2px 6px rgba(0,0,0,0.3);">
                        <i class="fas fa-flag text-white"></i>
                    </div>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            })
        }).addTo(routeLayer).bindPopup("Destination");
        
        // 3. Turn Instructions ==============================================
        
        // Handle both OSRM and legacy instruction formats
        if (route.instructions) {
            // OSRM format - steps are in maneuver property
            route.instructions.forEach((step, index) => {
                if (index === 0) return; // Skip starting point
                
                const coord = step.maneuver.location;
                const turnPoint = [coord[1], coord[0]];
                
                // Turn marker (small white circle with blue border)
                const turnMarker = L.marker(turnPoint, {
                    icon: L.divIcon({
                        className: 'turn-marker',
                        html: `
                            <div style="background-color: white; 
                                        border: 2px solid #4285F4; 
                                        width: 12px; 
                                        height: 12px; 
                                        border-radius: 50%; 
                                        box-shadow: 0 1px 4px rgba(0,0,0,0.2);">
                            </div>`,
                        iconSize: [12, 12],
                        iconAnchor: [6, 6]
                    })
                }).addTo(routeLayer);
                
                // Tooltip with instruction text
                turnMarker.bindTooltip(step.maneuver.instruction, {
                    permanent: false,
                    direction: 'top',
                    className: 'turn-tooltip'
                });
            });
        } else if (route.legs?.[0]?.steps) {
            // Legacy format - steps are direct properties
            let distanceCovered = 0;
            route.legs[0].steps.forEach((step, index) => {
                if (index === 0) return;
                distanceCovered += route.legs[0].steps[index - 1].distance;
                const turnPointIndex = findPointAtDistance(latLngs, distanceCovered);
                
                if (turnPointIndex >= 0) {
                    const turnPoint = latLngs[turnPointIndex];
                    const turnMarker = L.marker(turnPoint, {
                        icon: L.divIcon({
                            className: 'turn-marker',
                            html: `
                                <div style="background-color: white; 
                                            border: 2px solid #4285F4; 
                                            width: 12px; 
                                            height: 12px; 
                                            border-radius: 50%; 
                                            box-shadow: 0 1px 4px rgba(0,0,0,0.2);">
                                </div>`,
                            iconSize: [12, 12],
                            iconAnchor: [6, 6]
                        })
                    }).addTo(routeLayer);
                    
                    turnMarker.bindTooltip(step.instruction, {
                        permanent: false,
                        direction: 'top',
                        className: 'turn-tooltip'
                    });
                }
            });
        }
        
        // 4. Flood Warnings ================================================
        
        if (route.hasFlood && route.floodInfo) {
            const floodLocation = route.floodInfo.location;
            const floodMarker = L.marker([floodLocation.lat, floodLocation.lng], {
                icon: L.divIcon({
                    className: 'flood-warning-marker',
                    html: `
                        <div style="background-color: #EA4335; 
                                    color: white; 
                                    padding: 5px 10px; 
                                    border-radius: 4px; 
                                    font-weight: bold; 
                                    box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
                            <i class="fas fa-water mr-1"></i> Flood Warning
                        </div>`,
                    iconSize: [120, 30],
                    iconAnchor: [60, 15]
                })
            }).addTo(routeLayer);
            
            // Interactive popup with flood details
            floodMarker.bindPopup(`
                <div class="flood-info">
                    <h3 class="text-lg font-bold text-red-600">Flood Warning</h3>
                    <p>Severity: ${route.floodInfo.severity || 'Moderate'}</p>
                    <p>${route.floodInfo.description || 'This route passes through a flooded area.'}</p>
                    <button class="bg-blue-500 text-white px-3 py-1 rounded mt-2" 
                            onclick="findAlternativeRoute()">
                        Find Alternative Route
                    </button>
                </div>
            `);
        }
        
        // 5. Map View Adjustment ==========================================
        
        // Google Maps-like view adjustment
        floodMap.fitBounds(routeLine.getBounds(), { 
            padding: [50, 50],  // Add padding so markers aren't at edge
            maxZoom: 15         // Prevent zooming too far out
        });
      }
  
      // Helper function for maneuver icons
      function getManeuverIcon(maneuver) {
        const type = maneuver.type;
        const modifier = maneuver.modifier || '';
        
        if (type === 'turn') {
            switch(modifier) {
                case 'left': return '<i class="fas fa-arrow-turn-left"></i>';
                case 'right': return '<i class="fas fa-arrow-turn-right"></i>';
                case 'sharp left': return '<i class="fas fa-arrow-turn-down-left"></i>';
                case 'sharp right': return '<i class="fas fa-arrow-turn-down-right"></i>';
                default: return '<i class="fas fa-arrow-up"></i>';
            }
        } else if (type === 'arrive') {
            return '<i class="fas fa-flag-checkered"></i>';
        } else if (type === 'depart') {
            return '<i class="fas fa-location-dot"></i>';
        } else if (type === 'roundabout') {
            return '<i class="fas fa-rotate-right"></i>';
        } else {
            return '<i class="fas fa-arrow-up"></i>';
        }
      }
        
      // Helper function to find point at approximate distance along route
      function findPointAtDistance(coordinates, targetDistance) {
        let distanceSoFar = 0;
        
        for (let i = 1; i < coordinates.length; i++) {
          const segmentDistance = calculateDistance(
            coordinates[i-1][0], coordinates[i-1][1],
            coordinates[i][0], coordinates[i][1]
          );
          
          distanceSoFar += segmentDistance;
          
          if (distanceSoFar >= targetDistance) {
            return i;
          }
        }
        
        return -1;
      }
  
      // Calculate distance between two points in meters
      function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3; // Earth radius in meters
        const φ1 = lat1 * Math.PI / 180;
        const φ2 = lat2 * Math.PI / 180;
        const Δφ = (lat2 - lat1) * Math.PI / 180;
        const Δλ = (lon2 - lon1) * Math.PI / 180;
        
        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                  Math.cos(φ1) * Math.cos(φ2) *
                  Math.sin(Δλ/2) * Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        
        return R * c;
      }
  
      // Display route options in UI
      function displayRouteOptions() {
        const container = document.getElementById('routeOptionsList');
        if (!container) return;
        
        container.innerHTML = '';
        
        // Add header for route options
        const header = document.createElement('div');
        header.className = 'mb-3 text-gray-700 font-medium';
        header.innerHTML = `<div class="flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-blue-600" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd" />
          </svg>
          <span>${alternativeRoutes.length} routes available</span>
        </div>`;
        container.appendChild(header);
        
        // Create route options
        alternativeRoutes.forEach((route, index) => {
          const option = document.createElement('div');
          option.className = `route-option mb-3 p-4 rounded-lg shadow-sm border ${
            index === selectedRouteIndex 
              ? 'bg-blue-50 border-blue-400' 
              : 'bg-white border-gray-200 hover:bg-gray-50 cursor-pointer'
          } transition-all duration-200`;
          
          // Determine route characteristics
          const isFastest = route.duration === Math.min(...alternativeRoutes.map(r => r.duration));
          const isShortest = route.distance === Math.min(...alternativeRoutes.map(r => r.distance));
          const isSafest = !route.hasFlood && alternativeRoutes.some(r => r.hasFlood);
          
          // Create badge for route type (prioritize fastest > shortest > safest)
          let routeBadge = '';
          if (isFastest) {
            routeBadge = '<span class="bg-green-100 text-green-800 text-xs font-medium px-2 py-0.5 rounded-full mr-2">Fastest</span>';
          } else if (isShortest) {
            routeBadge = '<span class="bg-blue-100 text-blue-800 text-xs font-medium px-2 py-0.5 rounded-full mr-2">Shortest</span>';
          } else if (isSafest) {
            routeBadge = '<span class="bg-green-100 text-green-800 text-xs font-medium px-2 py-0.5 rounded-full mr-2">Safest</span>';
          }
          
          // Create risk indicator
          const riskBadge = `<span class="inline-flex items-center ${
            route.hasFlood 
              ? 'bg-red-100 text-red-800' 
              : 'bg-green-100 text-green-800'
          } text-xs font-medium px-2 py-0.5 rounded-full">
            ${route.hasFlood 
              ? '<svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>HIGH' 
              : '<svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M2.166 4.999A11.954 11.954 0 0010 1.944 11.954 11.954 0 0017.834 5c.11.65.166 1.32.166 2.001 0 5.225-3.34 9.67-8 11.317C5.34 16.67 2 12.225 2 7c0-.682.057-1.35.166-2.001zm11.541 3.708a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" /></svg>LOW'
            } risk</span>`;
          
          // Main content
          option.innerHTML = `
            <div class="flex items-start">
              <div class="flex-shrink-0 bg-${index === selectedRouteIndex ? 'blue' : 'gray'}-200 rounded-full h-8 w-8 flex items-center justify-center mr-3 text-${index === selectedRouteIndex ? 'blue' : 'gray'}-700 font-bold">
                ${index + 1}
              </div>
              <div class="flex-grow">
                <div class="flex flex-wrap items-center mb-1">
                  ${routeBadge}
                  ${riskBadge}
                </div>
                <div class="flex items-center text-gray-700 mb-2">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1 text-gray-500" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd" />
                  </svg>
                  <span class="text-sm font-medium">${(route.distance / 1000).toFixed(1)} km</span>
                  <span class="mx-2 text-gray-400">•</span>
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1 text-gray-500" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd" />
                  </svg>
                  <span class="text-sm font-medium">${formatDuration(route.duration)}</span>
                </div>
                ${route.hasFlood ? `
                <div class="text-xs text-red-600 flex items-center">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                  </svg>
                  This route passes through flooded areas
                </div>
                ` : ''}
              </div>
              <div class="flex-shrink-0 ml-2">
                <button class="text-blue-600 hover:text-blue-800 text-sm font-medium focus:outline-none" onclick="showRouteDetails(${index})">
                  Details
                </button>
              </div>
            </div>
          `;
          
          option.addEventListener('click', () => {
            selectRoute(index);
          });
          
          container.appendChild(option);
        });
        
        // Add "Start Navigation" button at the bottom
        const startNavButton = document.createElement('button');
        startNavButton.id = 'startNavigationBtn';
        startNavButton.className = `w-full py-3 px-4 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg shadow-md transition-colors duration-200 flex items-center justify-center ${selectedRouteIndex !== null ? '' : 'opacity-50 cursor-not-allowed'}`;
        startNavButton.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M10.293 15.707a1 1 0 010-1.414L14.586 10l-4.293-4.293a1 1 0 111.414-1.414l5 5a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0z" clip-rule="evenodd" />
            <path fill-rule="evenodd" d="M4.293 15.707a1 1 0 010-1.414L8.586 10 4.293 5.707a1 1 0 011.414-1.414l5 5a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0z" clip-rule="evenodd" />
          </svg>
          Start Navigation
        `;
        
        if (selectedRouteIndex !== null) {
          startNavButton.addEventListener('click', startNavigation);
        }
        
        container.appendChild(startNavButton);
      }
  
      // Select a specific route
      function selectRoute(index) {
        selectedRouteIndex = index;
        currentRoute = alternativeRoutes[index];
        currentRoute.isSelected = true;
        
        // Update UI
        displayRouteOptions(); // Redraw all options with new selection
        
        // Display the selected route with animation
        displayRoute(currentRoute);
        
        // Add a subtle highlight animation to the selected route
        const selectedOption = document.querySelectorAll('.route-option')[index];
        if (selectedOption) {
          selectedOption.classList.add('animate-pulse');
          setTimeout(() => {
            selectedOption.classList.remove('animate-pulse');
          }, 1000);
        }
        
        checkRouteSafety(currentRoute);
        
        // Update route info panel
        updateRouteInfoPanel(currentRoute);
        
        // Speak update if voice guidance is on
        if (voiceGuidance) {
          speak(`Selected route ${index + 1}. ${getRouteSummary(currentRoute)}`);
          setTimeout(() => speakNavigationInstructions(currentRoute.legs[0].steps), 1000);
        }
        
        // Show the route details panel
        showRouteDetails(index);
      }
  
      // Update the route info panel with details
      function updateRouteInfoPanel(route) {
        if (!route) return;
        
        document.getElementById('routeDistance').textContent = (route.distance / 1000).toFixed(1) + ' km';
        document.getElementById('routeDuration').textContent = formatDuration(route.duration);
        
        const riskElement = document.getElementById('routeRisk');
        riskElement.textContent = route.hasFlood ? 'HIGH' : 'LOW';
        riskElement.className = `font-medium ${route.hasFlood ? 'text-red-600' : 'text-green-600'}`;
        
        // Update ETA
        const now = new Date();
        const arrivalTime = new Date(now.getTime() + route.duration * 1000);
        const formattedTime = arrivalTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        const etaElement = document.getElementById('routeETA');
        if (etaElement) {
          etaElement.textContent = formattedTime;
        } else {
          // Create ETA element if it doesn't exist
          const infoPanel = document.getElementById('routeInfoPanel');
          if (infoPanel) {
            const etaDiv = document.createElement('div');
            etaDiv.className = 'flex items-center';
            etaDiv.innerHTML = `
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-gray-500" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd" />
              </svg>
              <span class="text-gray-700">ETA:</span>
              <span id="routeETA" class="ml-2 font-medium">${formattedTime}</span>
            `;
            infoPanel.appendChild(etaDiv);
          }
        }
      }
  
      // Show detailed information about a route
      function showRouteDetails(index) {
        const route = alternativeRoutes[index];
        if (!route) return;
        
        // Create or get route details panel
        let detailsPanel = document.getElementById('routeDetailsPanel');
        
        if (!detailsPanel) {
          detailsPanel = document.createElement('div');
          detailsPanel.id = 'routeDetailsPanel';
          detailsPanel.className = 'fixed inset-x-0 bottom-0 bg-white rounded-t-xl shadow-lg transform transition-transform duration-300 z-30';
          detailsPanel.style.maxHeight = '70vh';
          detailsPanel.style.overflowY = 'auto';
          document.body.appendChild(detailsPanel);
        }
        
        // Show the panel with slide-up animation
        detailsPanel.style.transform = 'translateY(0)';
        
        // Generate turn-by-turn instructions
        let instructionsHTML = '';
        
        if (route.legs && route.legs[0] && route.legs[0].steps) {
          instructionsHTML = route.legs[0].steps.map((step, i) => {
            // Determine icon based on maneuver type
            let icon = 'arrow-right';
            if (step.maneuver) {
              if (step.maneuver.includes('left')) icon = 'arrow-left';
              else if (step.maneuver.includes('right')) icon = 'arrow-right';
              else if (step.maneuver.includes('straight')) icon = 'arrow-up';
              else if (step.maneuver.includes('uturn')) icon = 'arrow-uturn-left';
            }
            
            // Highlight steps with flood warnings
            const hasFloodWarning = step.hasFlood;
            
            return `
              <div class="flex items-start p-3 border-b ${hasFloodWarning ? 'bg-red-50' : ''}">
                <div class="flex-shrink-0 bg-blue-100 rounded-full h-8 w-8 flex items-center justify-center mr-3 text-blue-700">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L12.586 11H5a1 1 0 110-2h7.586l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd" />
                  </svg>
                </div>
                <div class="flex-grow">
                  <div class="text-gray-800">${step.instruction}</div>
                  <div class="text-sm text-gray-500">${(step.distance / 1000).toFixed(2)} km • ${formatDuration(step.duration)}</div>
                  ${hasFloodWarning ? `
                    <div class="mt-1 text-xs text-red-600 flex items-center">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                      </svg>
                      Flood warning in this area
                    </div>
                  ` : ''}
                </div>
              </div>
            `;
          }).join('');
        } else {
          instructionsHTML = '<div class="p-4 text-gray-500">Turn-by-turn directions not available for this route.</div>';
        }
        
        // Populate the details panel
        detailsPanel.innerHTML = `
          <div class="flex justify-between items-center p-4 border-b">
            <h3 class="text-lg font-semibold">Route Details</h3>
            <button id="closeRouteDetails" class="text-gray-500 hover:text-gray-700">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
          
          <div class="p-4 bg-gray-50 border-b">
            <div class="flex justify-between items-center">
              <div>
                <div class="text-sm text-gray-500">Total Distance</div>
                <div class="text-lg font-semibold">${(route.distance / 1000).toFixed(1)} km</div>
              </div>
              <div>
                <div class="text-sm text-gray-500">Estimated Time</div>
                <div class="text-lg font-semibold">${formatDuration(route.duration)}</div>
              </div>
              <div>
                <div class="text-sm text-gray-500">Flood Risk</div>
                <div class="text-lg font-semibold ${route.hasFlood ? 'text-red-600' : 'text-green-600'}">${route.hasFlood ? 'HIGH' : 'LOW'}</div>
              </div>
            </div>
            
            ${route.hasFlood ? `
              <div class="mt-3 p-3 bg-red-100 text-red-800 rounded-lg flex items-start">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 flex-shrink-0" viewBox="0 0 20 20" fill="currentColor">
                  <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                </svg>
                <div>
                  <div class="font-medium">Flood Warning</div>
                  <div class="text-sm">This route passes through areas with active flooding. Consider alternative routes for your safety.</div>
                </div>
              </div>
            ` : ''}
          </div>
          
          <div class="p-4 border-b">
            <h4 class="font-medium mb-2">Turn-by-Turn Directions</h4>
            <div class="divide-y divide-gray-200">
              ${instructionsHTML}
            </div>
          </div>
          
          <div class="p-4">
            <button id="startNavigationFromDetails" class="w-full py-3 px-4 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg shadow-md transition-colors duration-200 flex items-center justify-center">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M10.293 15.707a1 1 0 010-1.414L14.586 10l-4.293-4.293a1 1 0 111.414-1.414l5 5a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                <path fill-rule="evenodd" d="M4.293 15.707a1 1 0 010-1.414L8.586 10 4.293 5.707a1 1 0 011.414-1.414l5 5a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0z" clip-rule="evenodd" />
              </svg>
              Start Navigation
            </button>
          </div>
        `;
        
        // Add event listeners
        document.getElementById('closeRouteDetails').addEventListener('click', () => {
          detailsPanel.style.transform = 'translateY(100%)';
        });
        
        document.getElementById('startNavigationFromDetails').addEventListener('click', startNavigation);
      }
  
      // Check route for flood risks
      function checkRouteSafety(route) {
        if (!route || !route.geometry || !route.geometry.coordinates) return;
        
        const coordinates = route.geometry.coordinates;
        let warnings = [];
        let highestSeverity = 'low';
        
        // Sample points along the route
        for (let i = 0; i < coordinates.length; i++) {
          const point = coordinates[i];
          const location = { lat: point[1], lng: point[0] };
          
          // Check nearby floods (using our mock data)
          const nearbyFloods = getNearbyFloods(location.lat, location.lng, 200);
          
          nearbyFloods.forEach(flood => {
            const severity = getSeverity(flood.water_level);
            const distance = getDistance(location, flood);
            
            warnings.push({
              severity,
              distance,
              location: flood,
              routePoint: location
            });
            
            if (severity === 'high' && highestSeverity !== 'high') {
              highestSeverity = 'high';
            } else if (severity === 'moderate' && highestSeverity === 'low') {
              highestSeverity = 'moderate';
            }
          });
        }
        
        // Update UI
        updateRouteRiskDisplay(warnings, highestSeverity);
        
        // Highlight danger zones on route
        highlightDangerZones(warnings);
        
        // Speak warning if high risk
        if (highestSeverity === 'high' && voiceGuidance) {
          speak("Warning! This route passes through high flood risk areas. Consider an alternative route.");
        }
        
        return { warnings, highestSeverity };
      }
  
      // Update route risk display with enhanced visuals
      function updateRouteRiskDisplay(warnings, highestSeverity) {
        const warningDiv = document.getElementById('routeRisk');
        if (!warningDiv) return;
        
        warningDiv.textContent = highestSeverity.toUpperCase();
        warningDiv.className = `font-medium ${
          highestSeverity === 'high' ? 'text-red-600' :
          highestSeverity === 'moderate' ? 'text-yellow-600' :
          'text-green-600'
        }`;
        
        // Show warning card if high risk
        if (highestSeverity === 'high') {
          // Create a more visually appealing notification
          const warningHTML = `
            <div class="flex items-start">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-white" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
              </svg>
              <div>
                <div class="font-bold">Flood Warning</div>
                <div>Route passes through high-risk flood areas</div>
              </div>
            </div>
          `;
          
          showNotification(warningHTML, "error");
          
          // Add a warning banner to the top of the route options
          const warningBanner = document.createElement('div');
          warningBanner.className = 'bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-4 rounded';
          warningBanner.innerHTML = `
            <div class="flex">
              <div class="flex-shrink-0">
                <svg class="h-5 w-5 text-red-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                  <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                </svg>
              </div>
              <div class="ml-3">
                <p class="text-sm font-medium">
                  This route passes through flooded areas. Consider alternative routes for your safety.
                </p>
              </div>
            </div>
          `;
          
          // Add to the top of the route options list
          const container = document.getElementById('routeOptionsList');
          if (container && !document.getElementById('floodWarningBanner')) {
            warningBanner.id = 'floodWarningBanner';
            container.insertBefore(warningBanner, container.firstChild);
          }
        } else {
          // Remove warning banner if it exists
          const existingBanner = document.getElementById('floodWarningBanner');
          if (existingBanner) {
            existingBanner.remove();
          }
        }
      }
  
      // Highlight danger zones on the route
      function highlightDangerZones(warnings) {
        riskRadiusLayer.clearLayers();
        
        // Clear previous highlights
        if (window.dangerZoneMarkers) {
          window.dangerZoneMarkers.forEach(marker => marker.remove());
        }
        window.dangerZoneMarkers = [];
        
        // Group warnings by location to avoid duplicates
        const groupedWarnings = {};
        warnings.forEach(warning => {
          const key = `${warning.location.lat.toFixed(5)},${warning.location.lng.toFixed(5)}`;
          if (!groupedWarnings[key] || warning.severity === 'high') {
            groupedWarnings[key] = warning;
          }
        });
        
        // Add markers for high and moderate severity warnings
        Object.values(groupedWarnings).forEach(warning => {
          if (warning.severity !== 'low') {
            const markerColor = warning.severity === 'high' ? '#ef4444' : '#f59e0b';
            
            // Create pulsing circle marker
            const marker = L.circleMarker([warning.location.lat, warning.location.lng], {
              radius: 12,
              color: markerColor,
              fillColor: markerColor,
              fillOpacity: 0.5,
              weight: 2,
              className: 'pulsing-marker'
            }).addTo(riskRadiusLayer);
            
            // Add popup with information
            marker.bindPopup(`
              <div class="flood-warning-popup">
                <h3 class="text-lg font-bold ${warning.severity === 'high' ? 'text-red-600' : 'text-yellow-600'}">
                  ${warning.severity.toUpperCase()} Flood Warning
                </h3>
                <p class="text-sm">Water level: ${warning.location.water_level} cm</p>
                <p class="text-sm">Distance from route: ${Math.round(warning.distance)} meters</p>
                <button class="mt-2 bg-blue-600 text-white text-sm px-3 py-1 rounded" onclick="findAlternativeRoute()">
                  Find Alternative Route
                </button>
              </div>
            `);
            
            window.dangerZoneMarkers.push(marker);
          }
        });
        
        // Add CSS for pulsing effect if not already added
        if (!document.getElementById('pulsing-marker-style')) {
          const style = document.createElement('style');
          style.id = 'pulsing-marker-style';
          style.textContent = `
            @keyframes pulse {
              0% { opacity: 0.7; transform: scale(1); }
              50% { opacity: 0.3; transform: scale(1.3); }
              100% { opacity: 0.7; transform: scale(1); }
            }
            
            .pulsing-marker {
              animation: pulse 1.5s infinite ease-in-out;
            }
            
            .flood-warning-popup h3 {
              margin-bottom: 8px;
            }
            
            .flood-warning-popup p {
              margin-bottom: 4px;
            }
          `;
          document.head.appendChild(style);
        }
      }
  
      // Function to find alternative route
      function findAlternativeRoute() {
        // Filter out routes with flood warnings
        const safeRoutes = alternativeRoutes.filter(route => !route.hasFlood);
        
        if (safeRoutes.length > 0) {
          // Find the fastest safe route
          const fastestSafeRoute = safeRoutes.reduce((fastest, route) => 
            route.duration < fastest.duration ? route : fastest, safeRoutes[0]);
          
          // Get the index of this route
          const safeRouteIndex = alternativeRoutes.findIndex(route => 
            route.geometry.coordinates === fastestSafeRoute.geometry.coordinates);
          
          // Select this route
          selectRoute(safeRouteIndex >= 0 ? safeRouteIndex : 0);
          
          showNotification(`
            <div class="flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
              </svg>
              <span>Switched to a safer route</span>
            </div>
          `);
        } else {
          showNotification(`
            <div class="flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
              </svg>
              <span>No safer routes available</span>
            </div>
          `, "error");
          
          // Show warning dialog with more information
          showSafetyDialog();
        }
      }
  
      // Show safety dialog when no safe routes are available
      function showSafetyDialog() {
        // Create modal if it doesn't exist
        let safetyModal = document.getElementById('safetyModal');
        
        if (!safetyModal) {
          safetyModal = document.createElement('div');
          safetyModal.id = 'safetyModal';
          safetyModal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
          safetyModal.innerHTML = `
            <div class="bg-white rounded-lg shadow-xl max-w-md w-full mx-4 overflow-hidden">
              <div class="bg-red-600 text-white px-6 py-4 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                </svg>
                <h3 class="text-lg font-bold">Flood Safety Warning</h3>
              </div>
              <div class="px-6 py-4">
                <p class="mb-4">All available routes pass through flooded areas. Travel is not recommended at this time.</p>
                <p class="mb-4">Consider:</p>
                <ul class="list-disc pl-5 mb-4">
                  <li>Postponing your journey if possible</li>
                  <li>Finding shelter at a safe location</li>
                  <li>Contacting emergency services if you're in immediate danger</li>
                </ul>
                <p class="text-sm text-gray-600 mb-4">If you must proceed, be aware of the following risks:</p>
                <div class="bg-yellow-50 border-l-4 border-yellow-400 p-3 mb-4">
                  <ul class="text-sm text-yellow-800">
                    <li>• Water may be deeper than it appears</li>
                    <li>• Road surfaces may be damaged or unstable</li>
                    <li>• Floodwater may contain hazardous materials</li>
                  </ul>
                </div>
              </div>
              <div class="px-6 py-3 bg-gray-50 flex justify-between">
                <button id="proceedAnywayBtn" class="px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-800 rounded">
                  Proceed Anyway
                </button>
                <button id="findAlternativeBtn" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded">
                  Find Alternative Destination
                </button>
              </div>
            </div>
          `;
          
          document.body.appendChild(safetyModal);
          
          // Add event listeners
          document.getElementById('proceedAnywayBtn').addEventListener('click', () => {
            safetyModal.remove();
            // Continue with the current route despite warnings
            if (selectedRouteIndex !== null) {
              startNavigation();
            }
          });
          
          document.getElementById('findAlternativeBtn').addEventListener('click', () => {
            safetyModal.remove();
            // Redirect to search page or show search UI
            showSearchUI();
          });
        } else {
          safetyModal.style.display = 'flex';
        }
      }
  
      // Show search UI for finding alternative destination
      function showSearchUI() {
        // This would show a search interface for finding a new destination
        // For now, we'll just show a notification
        showNotification('Opening search for alternative destinations...');
        
        // In a real implementation, this would open a search panel or redirect to search page
        setTimeout(() => {
          window.location.href = 'search.html';
        }, 1000);
      }
  
      // Start navigation with the selected route
      function startNavigation() {
        if (selectedRouteIndex === null) {
          showNotification('Please select a route first', 'error');
          return;
        }
        
        // Show loading state
        showNotification('Starting navigation...');
        
        // Hide route options and show navigation UI
        document.getElementById('routeOptions').classList.add('hidden');
        document.getElementById('navigationUI').classList.remove('hidden');
        
        // Set active route
        activeRoute = alternativeRoutes[selectedRouteIndex];
        
        // Initialize navigation system
        initializeNavigation(activeRoute);
        
        // Speak initial instructions if voice guidance is on
        if (voiceGuidance) {
          speak(`Starting navigation. ${getRouteSummary(activeRoute)}`);
          setTimeout(() => speakNavigationInstructions(activeRoute.legs[0].steps), 1000);
        }
      }
  
      // Initialize the navigation system with the selected route
      function initializeNavigation(route) {
        // Set up navigation display
        document.getElementById('navDistance').textContent = (route.distance / 1000).toFixed(1) + ' km';
        document.getElementById('navDuration').textContent = formatDuration(route.duration);
        document.getElementById('navRisk').textContent = route.hasFlood ? 'HIGH' : 'LOW';
        document.getElementById('navRisk').className = `font-medium ${route.hasFlood ? 'text-red-600' : 'text-green-600'}`;
        
        // Calculate ETA
        const now = new Date();
        const arrivalTime = new Date(now.getTime() + route.duration * 1000);
        document.getElementById('navETA').textContent = arrivalTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        // Set up turn-by-turn instructions
        setupTurnByTurnInstructions(route);
        
        // Start location tracking
        startLocationTracking();
        
        // Update map to navigation mode
        updateMapForNavigation(route);
      }
  
      // Set up turn-by-turn instructions panel
      function setupTurnByTurnInstructions(route) {
        const container = document.getElementById('turnByTurnInstructions');
        if (!container) return;
        
        container.innerHTML = '';
        
        if (route.legs && route.legs[0] && route.legs[0].steps) {
          route.legs[0].steps.forEach((step, index) => {
            const stepElement = document.createElement('div');
            stepElement.id = `nav-step-${index}`;
            stepElement.className = `p-3 border-b ${index === 0 ? 'bg-blue-50' : ''} ${step.hasFlood ? 'bg-red-50' : ''}`;
            
            // Determine icon based on maneuver type
            let iconName = 'arrow-right';
            if (step.maneuver) {
              if (step.maneuver.includes('left')) iconName = 'arrow-left';
              else if (step.maneuver.includes('right')) iconName = 'arrow-right';
              else if (step.maneuver.includes('straight')) iconName = 'arrow-up';
              else if (step.maneuver.includes('uturn')) iconName = 'arrow-uturn-left';
            }
            
            stepElement.innerHTML = `
              <div class="flex items-start">
                <div class="flex-shrink-0 bg-blue-100 rounded-full h-8 w-8 flex items-center justify-center mr-3 text-blue-700">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L12.586 11H5a1 1 0 110-2h7.586l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd" />
                  </svg>
                </div>
                <div class="flex-grow">
                  <div class="text-gray-800">${step.instruction}</div>
                  <div class="text-sm text-gray-500">${(step.distance / 1000).toFixed(2)} km</div>
                  ${step.hasFlood ? `
                    <div class="mt-1 text-xs text-red-600 flex items-center">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                      </svg>
                      Flood warning in this area
                    </div>
                  ` : ''}
                </div>
              </div>
            `;
            
            container.appendChild(stepElement);
          });
        } else {
          container.innerHTML = '<div class="p-4 text-gray-500">Turn-by-turn directions not available for this route.</div>';
        }
      }
  
      // Update map for navigation mode
      function updateMapForNavigation(route) {
        // Clear previous route layers
        routeLayer.clearLayers();
        
        // Convert coordinates to LatLng format
        const latLngs = route.geometry.coordinates.map(coord => [coord[1], coord[0]]);
        
        // Add route outline (white border effect)
        L.polyline(latLngs, {
          color: '#ffffff',
          weight: 9,
          opacity: 0.7,
          smoothFactor: 1.0,
          lineJoin: 'round',
          lineCap: 'round'
        }).addTo(routeLayer);
        
        // Add main route line
        const routeLine = L.polyline(latLngs, {
          color: route.hasFlood ? '#EA4335' : '#4285F4', // Red for flood routes, blue for safe routes
          weight: 5,
          opacity: 0.9,
          smoothFactor: 1.0,
          lineJoin: 'round',
          lineCap: 'round'
        }).addTo(routeLayer);
        
        // Add animated dash effect
        const animatedDash = L.polyline(latLngs, {
          color: '#4285F4',
          weight: 3,
          opacity: 0.8,
          dashArray: '10, 15',
          dashOffset: 0,
          smoothFactor: 1.0,
          lineJoin: 'round',
          lineCap: 'round'
        }).addTo(routeLayer);
        
        // Animate the dash
        let dashOffset = 0;
        const animateDash = () => {
          dashOffset -= 1;
          animatedDash.setStyle({ dashOffset });
          window.navAnimationId = requestAnimationFrame(animateDash);
        };
        window.navAnimationId = requestAnimationFrame(animateDash);
        
        // Add current location marker with direction indicator
        updateUserLocationMarker(latLngs[0], 0); // Start with first point and 0 bearing
        
        // Add destination marker
        const endPoint = latLngs[latLngs.length - 1];
        L.marker(endPoint, {
          icon: L.divIcon({ 
            className: 'end-marker',
            html: '<div class="end-marker-inner" style="background-color: #EA4335; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"><i class="fas fa-flag text-white"></i></div>',
            iconSize: [24, 24],
            iconAnchor: [12, 12]
          })
        }).addTo(routeLayer);
        
        // Fit map to route with padding
        floodMap.fitBounds(routeLine.getBounds(), { 
          padding: [50, 50],
          maxZoom: 15
        });
        
        // Add flood warning markers if applicable
        if (route.hasFlood && route.floodInfo) {
          addFloodWarningMarkers(route.floodInfo);
        }
      }
  
      // Add flood warning markers to the map
      function addFloodWarningMarkers(floodInfo) {
        if (Array.isArray(floodInfo)) {
          floodInfo.forEach(info => {
            addFloodWarningMarker(info);
          });
        } else {
          addFloodWarningMarker(floodInfo);
        }
      }
  
      // Add a single flood warning marker
      function addFloodWarningMarker(info) {
        const floodMarker = L.marker([info.location.lat, info.location.lng], {
          icon: L.divIcon({
            className: 'flood-warning-marker',
            html: '<div style="background-color: #EA4335; color: white; padding: 5px 10px; border-radius: 4px; font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.2);"><i class="fas fa-water mr-1"></i> Flood Warning</div>',
            iconSize: [120, 30],
            iconAnchor: [60, 15]
          })
        }).addTo(routeLayer);
        
        floodMarker.bindPopup(`
          <div class="flood-info">
            <h3 class="text-lg font-bold text-red-600">Flood Warning</h3>
            <p>Severity: ${info.severity || 'Moderate'}</p>
            <p>Water level: ${info.water_level || 'Unknown'} cm</p>
            <p>This route passes through a flooded area.</p>
          </div>
        `);
      }
  
      // Update user location marker with direction
      function updateUserLocationMarker(position, bearing) {
        // Remove previous marker if it exists
        if (window.userLocationMarker) {
          routeLayer.removeLayer(window.userLocationMarker);
        }
        
        // Create new marker with direction indicator
        window.userLocationMarker = L.marker(position, {
          icon: L.divIcon({
            className: 'user-location-marker',
            html: `
              <div style="position: relative;">
                <div style="background-color: #4285F4; width: 24px; height: 24px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);"></div>
                <div style="position: absolute; top: -5px; left: 50%; transform: translateX(-50%) rotate(${bearing}deg);">
                  <div style="width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 16px solid #4285F4;"></div>
                </div>
              </div>
            `,
            iconSize: [40, 40],
            iconAnchor: [20, 20]
          })
        }).addTo(routeLayer);
        
        // Center map on user location
        floodMap.panTo(position);
      }
  
      // Start location tracking for navigation
      function startLocationTracking() {
        // In a real app, this would use the Geolocation API
        // For demo purposes, we'll simulate movement along the route
        
        if (window.locationSimulationInterval) {
          clearInterval(window.locationSimulationInterval);
        }
        
        let currentStepIndex = 0;
        let progress = 0;
        const route = activeRoute;
        const coordinates = route.geometry.coordinates.map(coord => [coord[1], coord[0]]);
        
        window.locationSimulationInterval = setInterval(() => {
          if (currentStepIndex >= coordinates.length - 1) {
            // Reached destination
            clearInterval(window.locationSimulationInterval);
            onDestinationReached();
            return;
          }
          
          // Calculate current position along the route
          const currentPoint = coordinates[currentStepIndex];
          const nextPoint = coordinates[currentStepIndex + 1];
          
          // Interpolate between points based on progress
          const lat = currentPoint[0] + (nextPoint[0] - currentPoint[0]) * progress;
          const lng = currentPoint[1] + (nextPoint[1] - currentPoint[1]) * progress;
          
          // Calculate bearing (direction)
          const bearing = calculateBearing(currentPoint[0], currentPoint[1], nextPoint[0], nextPoint[1]);
          
          // Update user location marker
          updateUserLocationMarker([lat, lng], bearing);
          
          // Update navigation UI
          updateNavigationUI(currentStepIndex, progress);
          
          // Increment progress
          progress += 0.1;
          if (progress >= 1) {
            progress = 0;
            currentStepIndex++;
            
            // Update active step in turn-by-turn instructions
            updateActiveNavigationStep(currentStepIndex);
          }
        }, 1000); // Update every second
      }
  
      // Calculate bearing between two points
      function calculateBearing(lat1, lon1, lat2, lon2) {
        const φ1 = lat1 * Math.PI / 180;
        const φ2 = lat2 * Math.PI / 180;
        const λ1 = lon1 * Math.PI / 180;
        const λ2 = lon2 * Math.PI / 180;
        
        const y = Math.sin(λ2 - λ1) * Math.cos(φ2);
        const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1);
        const θ = Math.atan2(y, x);
        
        return (θ * 180 / Math.PI + 360) % 360;
      }
  
      // Update the active step in turn-by-turn instructions
      function updateActiveNavigationStep(stepIndex) {
        // Remove highlight from all steps
        document.querySelectorAll('[id^="nav-step-"]').forEach(el => {
          el.classList.remove('bg-blue-50');
        });
        
        // Highlight current step
        const currentStep = document.getElementById(`nav-step-${stepIndex}`);
        if (currentStep) {
          currentStep.classList.add('bg-blue-50');
          currentStep.scrollIntoView({ behavior: 'smooth', block: 'center' });
          
          // Speak instruction if voice guidance is on
          if (voiceGuidance && activeRoute.legs && activeRoute.legs[0] && activeRoute.legs[0].steps) {
            const instruction = activeRoute.legs[0].steps[stepIndex].instruction;
            speak(instruction);
          }
        }
      }
  
      // Update navigation UI with progress
      function updateNavigationUI(stepIndex, progress) {
        if (!activeRoute.legs || !activeRoute.legs[0] || !activeRoute.legs[0].steps) return;
        
        // Calculate remaining distance and time
        let remainingDistance = 0;
        let remainingTime = 0;
        
        const steps = activeRoute.legs[0].steps;
        for (let i = stepIndex; i < steps.length; i++) {
          if (i === stepIndex) {
            // For current step, account for progress
            remainingDistance += steps[i].distance * (1 - progress);
            remainingTime += steps[i].duration * (1 - progress);
          } else {
            remainingDistance += steps[i].distance;
            remainingTime += steps[i].duration;
          }
        }
        
        // Update UI
        document.getElementById('navRemainingDistance').textContent = (remainingDistance / 1000).toFixed(1) + ' km';
        document.getElementById('navRemainingTime').textContent = formatDuration(remainingTime);
        
        // Update ETA
        const now = new Date();
        const arrivalTime = new Date(now.getTime() + remainingTime * 1000);
        document.getElementById('navETA').textContent = arrivalTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }
  
      // Handle reaching destination
      function onDestinationReached() {
        // Show destination reached notification
        showNotification(`
          <div class="flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
            </svg>
            <span>You have reached your destination!</span>
          </div>
        `);
        
        // Speak if voice guidance is on
        if (voiceGuidance) {
          speak("You have reached your destination.");
        }
        
        // Show destination reached dialog
        showDestinationReachedDialog();
      }
  
      // Show destination reached dialog
      function showDestinationReachedDialog() {
        const dialog = document.createElement('div');
        dialog.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        dialog.innerHTML = `
          <div class="bg-white rounded-lg shadow-xl max-w-md w-full mx-4 overflow-hidden">
            <div class="bg-green-600 text-white px-6 py-4 flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
              </svg>
              <h3 class="text-lg font-bold">Destination Reached</h3>
            </div>
            <div class="px-6 py-4">
              <p class="mb-4">You have successfully reached your destination.</p>
              <p class="mb-4">Would you like to:</p>
              <div class="space-y-2">
                <button id="saveRouteBtn" class="w-full py-2 px-4 bg-blue-600 hover:bg-blue-700 text-white rounded transition-colors duration-200 flex items-center justify-center">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M5 4a2 2 0 012-2h6a2 2 0 012 2v14l-5-2.5L5 18V4z" />
                  </svg>
                  Save this route
                </button>
                <button id="findNewRouteBtn" class="w-full py-2 px-4 bg-gray-200 hover:bg-gray-300 text-gray-800 rounded transition-colors duration-200 flex items-center justify-center">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                  </svg>
                  Find a new route
                </button>
                <button id="closeNavigationBtn" class="w-full py-2 px-4 bg-gray-200 hover:bg-gray-300 text-gray-800 rounded transition-colors duration-200 flex items-center justify-center">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                  </svg>
                  Close navigation
                </button>
              </div>
            </div>
          </div>
        `;
        
        document.body.appendChild(dialog);
        
        // Add event listeners
        document.getElementById('saveRouteBtn').addEventListener('click', () => {
          saveRoute(activeRoute);
          dialog.remove();
        });
        
        document.getElementById('findNewRouteBtn').addEventListener('click', () => {
          dialog.remove();
          window.location.href = 'search.html';
        });
        
        document.getElementById('closeNavigationBtn').addEventListener('click', () => {
          dialog.remove();
          window.location.href = 'index.html';
        });
      }
  
      // Save route to user's saved routes
      function saveRoute(route) {
        // In a real app, this would save to backend
        // For demo, we'll save to localStorage
        
        const savedRoutes = JSON.parse(localStorage.getItem('floodsafe_saved_routes') || '[]');
        
        const routeToSave = {
          id: Date.now(),
          name: `Route to ${route.destination || 'Destination'}`,
          origin: route.origin || 'Current Location',
          destination: route.destination || 'Destination',
          distance: route.distance,
          duration: route.duration,
          hasFlood: route.hasFlood,
          date: new Date().toISOString(),
          geometry: route.geometry
        };
        
        savedRoutes.push(routeToSave);
        localStorage.setItem('floodsafe_saved_routes', JSON.stringify(savedRoutes));
        
        showNotification(`
          <div class="flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
              <path d="M5 4a2 2 0 012-2h6a2 2 0 012 2v14l-5-2.5L5 18V4z" />
            </svg>
            <span>Route saved successfully</span>
          </div>
        `);
      }
  
      // Speak navigation instructions
      function speakNavigationInstructions(steps) {
          if (!voiceGuidance || !steps || steps.length < 2) return;
          
          speechSynthesis.cancel();
          
          // Initial announcement
          speak(`Route calculated. ${getRouteSummary(currentRoute)}`);
          
          // Process steps with timing
          steps.forEach((step, index) => {
              if (index === 0) return; // Skip departure
              
              const distance = step.distance;
              let announceAt = 0;
              
              // Calculate when to announce based on distance
              if (distance > 1000) {
                  announceAt = distance - 1000; // Announce 1km before
                  setTimeout(() => {
                      speak(`In 1 kilometer, ${formatInstruction(step)}`);
                  }, calculateDelay(announceAt));
              }
              
              if (distance > 500) {
                  announceAt = distance - 500; // Announce 500m before
                  setTimeout(() => {
                      speak(`In 500 meters, ${formatInstruction(step)}`);
                  }, calculateDelay(announceAt));
              }
              
              announceAt = distance - 200; // Final announcement 200m before
              setTimeout(() => {
                  speak(formatInstruction(step));
                  
                  // Special flood warnings
                  if (step.hasFlood) {
                      setTimeout(() => {
                          speak("Caution! Flooded area ahead.");
                      }, 1000);
                  }
              }, calculateDelay(announceAt));
          });
      }
      
      function formatInstruction(step) {
          const street = step.name || extractStreetName(step.maneuver.instruction);
          const action = getSpokenAction(step.maneuver);
          
          return street ? `${action} ${street}` : action;
      }
      
      function extractStreetName(instruction) {
          // 1. Handle "onto" patterns
          const ontoMatch = instruction.match(/onto (.+?)(?:\.|$)/i);
          if (ontoMatch) return ontoMatch[1];
          // 2. Handle toward patterns
          const towardMatch = instruction.match(/toward (.+?)(?:\.|$)/i);
          if (towardMatch) return towardMatch[1];
          // 3. Handle "continue" patterns
          const continueMatch = instruction.match(/Continue (?:on|along) (.+?)(?:\.|$)/i);
          if (continueMatch) return continueMatch[1];
          // 4. Handle "keep left/ Right on" patterns
          const keepLeftMatch = instruction.match(/Keep left on (.+?)(?:\.|$)/i);
          if (keepLeftMatch) return keepLeftMatch[1];

          const keepRightMatch = instruction.match(/Keep Right on (.+?)(?:\.|$)/i);
          if (keepRightMatch) return keepRightMatch[1];
          // 5. Handle "Merge onto" patterns
          const mergeMatch = instruction.match(/Merge onto (.+?)(?:\.|$)/i);
          if (mergeMatch) return mergeMatch[1];
          // 6. Handle "Turn slight left/ right onto" patterns
          const turnLeftMatch = instruction.match(/Turn slight left onto (.+?)(?:\.|$)/i);
          if (turnLeftMatch) return turnLeftMatch[1];

          const turnRightMatch = instruction.match(/Turn slight right onto (.+?)(?:\.|$)/i);
          if (turnRightMatch) return turnRightMatch[1];
          // 7. Handle "Turn left/ right onto" patterns
          const turnLeftMatch2 = instruction.match(/Turn left onto (.+?)(?:\.|$)/i);
          if (turnLeftMatch2) return turnLeftMatch2[1];

          const turnRightMatch2 = instruction.match(/Turn right onto (.+?)(?:\.|$)/i);
          if (turnRightMatch2) return turnRightMatch2[1];

          // 8. Handle "Take the [ number] exit onto" patterns for roundabouts
          const roundaboutMatch = instruction.match(/Take the (\d+)(?:st|nd|rd|th) exit onto (.+?)(?:\.|$)/i);
          if (roundaboutMatch) return roundaboutMatch[2];

          // 9. Handle "Take the [ number] exit" patterns for roundabouts
          const roundaboutMatch2 = instruction.match(/Take the (\d+)(?:st|nd|rd|th) exit/i);
          if (roundaboutMatch2) return roundaboutMatch2[1];

          // 10. Handle "follow" patterns
          const followMatch = instruction.match(/Follow (.+?)(?:\.|$)/i);
          if (followMatch) return followMatch[1];

          // 11. Handle "go straight" patterns
          const goStraightMatch = instruction.match(/Go straight (?:on|along) (.+?)(?:\.|$)/i);
          if (goStraightMatch) return goStraightMatch[1];

          // 12. Handle "continue straight" patterns
          const continueStraightMatch = instruction.match(/Continue straight (?:on|along) (.+?)(?:\.|$)/i);
          if (continueStraightMatch) return continueStraightMatch[1];

          // 13. Handle "proceed straight" patterns
          const proceedStraightMatch = instruction.match(/Proceed straight (?:on|along) (.+?)(?:\.|$)/i);
          if (proceedStraightMatch) return proceedStraightMatch[1];

          // 14. Fallback: if nothing is found, try to extract the last word
          const words = instruction.split(' ');
          if (words.length > 1) {
              return words[words.length - 1].replace(/[^a-zA-Z0-9]/g, ''); // Remove special characters
          }

          return null;
      }
      
      function getSpokenAction(maneuver) {
          switch(maneuver.type) {
              case 'turn':
                  switch(maneuver.modifier) {
                      case 'left': return 'Turn left onto';
                      case 'right': return 'Turn right onto';
                      case 'sharp left': return 'Make a sharp left onto';
                      case 'sharp right': return 'Make a sharp right onto';
                      case 'slight left': return 'Bear left onto';
                      case 'slight right': return 'Bear right onto';
                      default: return 'Turn onto';
                  }
              case 'roundabout': return `Take the ${maneuver.exit} exit onto`;
              case 'merge': return 'Merge onto';
              case 'fork': return 'Keep left onto';
              default: return 'Continue onto';
          }
      }
      
      function calculateDelay(distance) {
          // Assuming average speed of 50km/h (13.89 m/s)
          const seconds = distance / 13.89 * 1000;
          return Math.max(seconds, 2000); // Minimum 2 second delay
      }
  
      // Format distance for natural speech
      function formatDistanceForSpeech(distanceMeters) {
        if (distanceMeters > 1000) {
            return `${(distanceMeters / 1000).toFixed(1)} kilometers`;
        } else {
            return `${Math.round(distanceMeters / 50) * 50} meters`; // Round to nearest 50m
        }
      }
  
      // Enhanced route summary with key details
      function getRouteSummary(route) {
        let summary = `Your route is ${(route.distance / 1000).toFixed(1)} kilometers long. `;
        summary += `Estimated travel time is ${formatDuration(route.duration)}. `;
        
        if (route.hasFlood) {
            summary += "Warning! This route passes through flooded areas. ";
        } else {
            summary += "This route appears clear of flood hazards. ";
        }
        
        return summary;
      }
  
      // Check input field for safety
      async function checkInputSafety(inputId) {
        const inputElement = document.getElementById(inputId);
        const riskElement = document.getElementById(`${inputId}Risk`);
        const address = inputElement.value.trim();
        
        if (!address || address.length < 3) {
          if (riskElement) riskElement.classList.add('hidden');
          return;
        }
        
        if (riskElement) {
          riskElement.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i> Checking safety...';
          riskElement.className = `risk-indicator p-2 bg-gray-100 text-gray-700`;
          riskElement.classList.remove('hidden');
        }
        
        try {
          // For demo purposes, we'll simulate risk assessment
          // In a real app, you would geocode the address and check nearby floods
          const risk = simulateRiskAssessment(address);
          updateRiskDisplay(risk, riskElement, inputId);
          
          // Visualize on map
          visualizeRiskZone(risk.location, risk);
        } catch (error) {
          console.error(`Error checking ${inputId} safety:`, error);
          if (riskElement) {
            riskElement.innerHTML = '<i class="fas fa-exclamation-circle mr-1"></i> Check failed';
            riskElement.className = 'risk-indicator p-2 bg-yellow-100 text-yellow-800';
          }
        }
      }
  
      // Simulate risk assessment for demo purposes
      function simulateRiskAssessment(address) {
        // This is just for demonstration - in a real app you would use real data
        const randomRisk = Math.random();
        let riskLevel, waterLevel;
        
        if (randomRisk > 0.8) {
          riskLevel = 'high';
          waterLevel = Math.floor(Math.random() * 30) + 70; // 70-100 cm
        } else if (randomRisk > 0.5) {
          riskLevel = 'moderate';
          waterLevel = Math.floor(Math.random() * 30) + 40; // 40-70 cm
        } else {
          riskLevel = 'low';
          waterLevel = Math.floor(Math.random() * 30) + 10; // 10-40 cm
        }
        
        // Generate some mock nearby floods
        const baseLat = 14.1667 + (Math.random() * 0.02 - 0.01);
        const baseLng = 121.2167 + (Math.random() * 0.02 - 0.01);
        
        const nearbyFloods = [
          { latitude: baseLat + 0.001, longitude: baseLng + 0.001, water_level: waterLevel },
          { latitude: baseLat - 0.002, longitude: baseLng + 0.001, water_level: waterLevel - 10 }
        ].filter(f => f.water_level > 0);
        
        return {
          level: riskLevel,
          location: { lat: baseLat, lng: baseLng, address: address },
          hotspots: nearbyFloods.map(flood => ({
            distance: Math.floor(Math.random() * 300) + 50,
            severity: getSeverity(flood.water_level),
            waterLevel: flood.water_level
          })),
          timestamp: Date.now()
        };
      }
  
      // Update risk display
      function updateRiskDisplay(risk, element, context) {
        const riskLevel = risk.level;
        const riskConfig = RISK_LEVELS[riskLevel];
        
        // Update inline indicator
        if (element) {
          element.innerHTML = `<i class="fas ${riskConfig.icon} mr-1"></i> ${riskConfig.title}`;
          element.className = `risk-indicator p-2 bg-${riskLevel}-100 text-${riskLevel}-800`;
          element.classList.remove('hidden');
        }
        
        // Update the main risk card
        const riskCard = document.getElementById('locationRiskCard');
        const riskIcon = document.getElementById('riskIcon');
        const riskTitle = document.getElementById('riskTitle');
        const riskDetails = document.getElementById('riskDetails');
        const hotspotList = document.getElementById('hotspotList');
        const riskHotspots = document.getElementById('riskHotspots');
        
        if (riskIcon) riskIcon.className = `fas ${riskConfig.icon} text-${riskLevel}-500`;
        if (riskTitle) {
          riskTitle.textContent = `${riskConfig.title} Area`;
          riskTitle.className = `font-bold text-${riskLevel}-800`;
        }
        
        if (riskDetails) {
          if (context === 'startInput') {
            riskDetails.textContent = `Start location has ${riskLevel} flood risk`;
          } else if (context === 'endInput') {
            riskDetails.textContent = `Destination has ${riskLevel} flood risk`;
          } else {
            riskDetails.textContent = `This location has ${riskLevel} flood risk`;
          }
        }
        
        // Show nearby hotspots if any
        if (hotspotList && riskHotspots) {
          if (risk.hotspots && risk.hotspots.length > 0) {
            hotspotList.innerHTML = risk.hotspots.slice(0, 3).map(hotspot => `
              <div class="flex items-center text-xs">
                <i class="fas fa-location-dot mr-2" style="color: ${RISK_LEVELS[hotspot.severity].color}"></i>
                ${hotspot.distance}m away (${hotspot.waterLevel}cm)
              </div>
            `).join('');
            
            if (risk.hotspots.length > 3) {
              hotspotList.innerHTML += `<div class="text-xs text-gray-500 mt-1">+ ${risk.hotspots.length - 3} more nearby</div>`;
            }
            
            riskHotspots.classList.remove('hidden');
          } else {
            riskHotspots.classList.add('hidden');
          }
        }
        
        if (riskCard) {
          riskCard.className = `bg-white p-4 rounded-lg shadow-md mb-4 border-l-4 border-${riskLevel}-500`;
          riskCard.classList.remove('hidden');
        }
      }
  
      // Visualize risk zone on map
      function visualizeRiskZone(location, risk) {
        riskRadiusLayer.clearLayers();
        
        // Add pulsing danger radius
        L.circle([location.lat, location.lng], {
          color: RISK_LEVELS[risk.level].color,
          fillColor: RISK_LEVELS[risk.level].color,
          fillOpacity: 0.2,
          radius: 500 // 500m radius
        }).addTo(riskRadiusLayer);
        
        // Add pulsing effect
        L.circle([location.lat, location.lng], {
          color: RISK_LEVELS[risk.level].color,
          fillColor: RISK_LEVELS[risk.level].color,
          fillOpacity: 0.1,
          radius: 300,
          className: 'pulse-ring'
        }).addTo(riskRadiusLayer);
        
        // Add marker for the location
        L.marker([location.lat, location.lng], {
          icon: L.divIcon({
            className: 'risk-marker',
            html: `<div class="risk-marker-inner" style="background-color: ${RISK_LEVELS[risk.level].color}">
                    <i class="fas ${RISK_LEVELS[risk.level].icon} text-white"></i>
                  </div>`,
            iconSize: [30, 30]
          })
        }).addTo(riskRadiusLayer)
        .bindPopup(`<b>${location.address || 'Location'}</b><br>${RISK_LEVELS[risk.level].title}`);
        
        // Pan map to the location if it's not visible
        if (!floodMap.getBounds().contains([location.lat, location.lng])) {
          floodMap.setView([location.lat, location.lng], 15);
        }
      }
  
      // Get nearby floods (using mock data)
      function getNearbyFloods(lat, lng, radius) {
        const allFloods = [
          { id: 1, latitude: 14.1667, longitude: 121.2167, water_level: 85 },
          { id: 2, latitude: 14.1700, longitude: 121.2200, water_level: 45 },
          { id: 3, latitude: 14.1630, longitude: 121.2100, water_level: 25 },
          { id: 4, latitude: 14.1750, longitude: 121.2250, water_level: 65 },
          { id: 5, latitude: 14.1600, longitude: 121.2300, water_level: 35 }
        ];
        
        return allFloods.filter(flood => {
          const distance = getDistance({ lat, lng }, flood);
          return distance <= radius;
        });
      }

           // Function to check for flood alerts
        async function checkFloodAlerts() {
          try {
              const response = await fetch('/api/flood-data');
              const data = await response.json();
              
              if (!data.nodes || data.nodes.length === 0) return;
              
              // Check for severe flood conditions
              let hasSevereFlood = false;
              let hasWarningFlood = false;
              
              data.nodes.forEach(node => {
                  if (node.flood_status === 'SEVERE' || node.severity === 'HIGH') {
                      hasSevereFlood = true;
                  } else if (node.flood_status === 'WARNING' || node.severity === 'MODERATE') {
                      hasWarningFlood = true;
                  }
              });
              
              const alertElement = document.getElementById('flood-alert');
              const alertText = alertElement.querySelector('.alert-text');
              
              if (hasSevereFlood) {
                  alertElement.classList.remove('hidden', 'bg-yellow-50', 'border-yellow-200', 'text-yellow-700');
                  alertElement.classList.add('bg-red-50', 'border-red-200', 'text-red-700');
                  alertText.textContent = 'Severe flooding reported in your area. Please stay safe and avoid flood-prone routes.';
              } else if (hasWarningFlood) {
                  alertElement.classList.remove('hidden', 'bg-red-50', 'border-red-200', 'text-red-700');
                  alertElement.classList.add('bg-yellow-50', 'border-yellow-200', 'text-yellow-700');
                  alertText.textContent = 'Flood warning in effect. Some areas may experience flooding.';
              } else {
                  alertElement.classList.add('hidden');
              }
          } catch (error) {
              console.error("Error checking flood alerts:", error);
          }
      }
      
      // Check for alerts when page loads and every 30 seconds
      document.addEventListener('DOMContentLoaded', () => {
          checkFloodAlerts();
          setInterval(checkFloodAlerts, 30000);
      });
  
      // Helper functions
      function debounce(func, timeout = 500) {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => { func.apply(this, args); }, timeout);
        };
      }
  
      function showNotification(message, type = "info") {
        const notification = document.createElement('div');
        notification.className = `notification fixed top-4 right-4 p-3 rounded-md text-white text-sm max-w-xs ${
          type === "error" ? "bg-red-500" :
          type === "warning" ? "bg-yellow-500" :
          type === "success" ? "bg-green-500" :
          "bg-blue-500"
        }`;
        notification.innerHTML = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.classList.add('opacity-0', 'transition-opacity', 'duration-500');
          setTimeout(() => notification.remove(), 500);
        }, 3000);
      }
  
      function formatDuration(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        return hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
      }
  
      function getSeverity(waterLevel) {
        return waterLevel > 70 ? 'high' :
               waterLevel > 40 ? 'moderate' :
               'low';
      }
  
      function getDistance(pos1, pos2) {
        const R = 6371e3;
        const φ1 = pos1.lat * Math.PI/180;
        const φ2 = pos2.latitude * Math.PI/180;
        const Δφ = (pos2.latitude-pos1.lat) * Math.PI/180;
        const Δλ = (pos2.longitude-pos1.lng) * Math.PI/180;
  
        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                  Math.cos(φ1) * Math.cos(φ2) *
                  Math.sin(Δλ/2) * Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  
        return Math.round(R * c);
      }

    </script>
  <footer class="bg-blue-600 text-white py-4">
    <div class="max-w-4xl mx-auto px-4">
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <!-- About Us Section -->
            <div>
                <h3 class="text-base font-bold mb-2">About Us</h3>
                <p class="text-blue-100 text-xs">
                    We provide real-time flood detection and route optimization to ensure safer travel during extreme weather conditions.
                </p>
            </div>

            <!-- Quick Links Section -->
            <div>
                <h3 class="text-base font-bold mb-2">Quick Links</h3>
                <ul class="space-y-0.5 text-xs text-blue-100">
                    <li><a href="index.html" class="hover:underline">Home</a></li>
                    <li><a href="about.html" class="hover:underline">About Us</a></li>
                    <li><a href="navigation.html" class="hover:underline">Navigation</a></li>
                    <li><a href="flood-data.html" class="hover:underline">Flood Data</a></li>
                </ul>
            </div>

            <!-- Connect With Us Section -->
            <div class="flex flex-col items-start">
                <h3 class="text-base font-bold mb-2">Connect With Us</h3>
                <div class="flex space-x-3 text-lg">
                    <a href="#" class="text-white hover:text-gray-300"><i class="fab fa-facebook-f"></i></a>
                    <a href="#" class="text-white hover:text-gray-300"><i class="fab fa-twitter"></i></a>
                    <a href="#" class="text-white hover:text-gray-300"><i class="fab fa-instagram"></i></a>
                    <a href="#" class="text-white hover:text-gray-300"><i class="fab fa-linkedin-in"></i></a>
                </div>
            </div>
        </div>

        <!-- Footer Bottom -->
        <div class="mt-4 text-center text-xs text-blue-100">
            © 2025 FloodSafe Navigation. All rights reserved.
        </div>
    </div>
</footer>
<!-- Add chatbot script -->
<script src="script/chatbot.js"></script>
<script src="script/route-optimization.js"></script>
<script src="script/flood-detection.js"></script>
<script src="script/ml-integration.js"></script>
</body>
</html>